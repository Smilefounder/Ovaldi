<?xml version="1.0" encoding="utf-8"?>
<Page xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/Ovaldi.Core.Models">
	<AbsoluteName>-zealotrouge-p-3890359.html</AbsoluteName>
	<CustomFields xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<EnableScript>true</EnableScript>
	<EnableTheming>true</EnableTheming>
	<Html>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-cn"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;由一个简单算法想到的程序员素养问题 - 热气球 - 博客园&lt;/title&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/bundles/blog-common.css"&gt;
&lt;link id="MainCss" type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/skins/facebook/bundle-facebook.css"&gt;
&lt;link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/zealotrouge/rss"&gt;
&lt;link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/zealotrouge/rsd.xml"&gt;
&lt;link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/zealotrouge/wlwmanifest.xml"&gt;
&lt;script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"&gt;&lt;/script&gt;  
&lt;script type="text/javascript"&gt;var currentBlogApp = 'zealotrouge', cb_enable_mathjax=false;&lt;/script&gt;
&lt;script src="/preview~Cnblogs/Scripts/bundles/blog-common.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a name="top"&gt;&lt;/a&gt;

&lt;div id="home"&gt;
&lt;div id="header"&gt;
	&lt;div id="blogTitle"&gt;
		
&lt;!--done--&gt;
&lt;h1&gt;&lt;a id="Header2_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/zealotrouge/"&gt;热气球&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;&lt;/h2&gt;



		
	&lt;/div&gt;&lt;!--end: blogTitle 博客的标题和副标题 --&gt;
	&lt;div id="navigator"&gt;
		
&lt;!--done--&gt;
			&lt;ul id="navList"&gt;
				&lt;li&gt;&lt;a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/"&gt;博客园&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/zealotrouge/"&gt;首页&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a id="MyLinks1_NewPostLink" class="menu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1"&gt;新随笔&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a id="MyLinks1_ContactLink" accesskey="9" class="menu" rel="nofollow" href="http://space.cnblogs.com/msg/send/%e7%83%ad%e6%b0%94%e7%90%83"&gt;联系&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/"&gt;管理&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/zealotrouge/rss"&gt;订阅&lt;/a&gt;
				&lt;a id="MyLinks1_XMLLink" class="aHeaderXML" href="http://www.cnblogs.com/zealotrouge/rss"&gt;&lt;img src="/preview~Cnblogs/Images/images/xml.gif" alt="订阅"&gt;&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;


		&lt;div class="blogStats"&gt;
			
			
&lt;!--done--&gt;
随笔- 17&amp;nbsp;
文章- 13&amp;nbsp;
评论- 124&amp;nbsp;

			
		&lt;/div&gt;&lt;!--end: blogStats --&gt;
	&lt;/div&gt;&lt;!--end: navigator 博客导航栏 --&gt;
&lt;/div&gt;&lt;!--end: header 头部 --&gt;

&lt;div id="main"&gt;
	&lt;div id="mainContent"&gt;
	&lt;div class="forFlow"&gt;
		

&lt;!--done--&gt;
&lt;div id="topics"&gt;
	&lt;div class="post"&gt;
		&lt;h1 class="postTitle"&gt;
			&lt;a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/zealotrouge/p/3890359.html"&gt;由一个简单算法想到的程序员素养问题&lt;/a&gt;
		&lt;/h1&gt;
		&lt;div class="clear"&gt;&lt;/div&gt;
		&lt;div class="postBody"&gt;
			&lt;div id="cnblogs_post_body"&gt;&lt;p&gt;　　题记：五月从帝都回到武汉，旅游半个月后开始找新工作，六月选择了一家华中地区为数不多的移动互联网公司入职至今，略有感触&amp;mdash;&amp;mdash;比较帝都码农与武汉码农的平均水平，就跟两个城市的经济发展水平差异一样大，不是说武汉这边没有优秀的程序员（我也算半个嘛），而是说平均水平确实不如其他一线城市。想想也正常，巨头公司都扎堆北上广深，以极具竞争力的薪酬福利和巨头光环吸引着广大程序员，反观武汉的互联网发展尚处在初级阶段，无论从公司规模、名气还是最实际的薪酬福利方面均不如一线城市，自然无法吸引广大程序员咯。本人&lt;span style="line-height: 1.5;"&gt;在新公司待了近三个月，慢慢发现代码中的一些问题，而这些问题中除开因为个人能力短时间无法解决的，剩下的就是我想探讨的程序员素养问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　先说下我所认为的程序员素养吧，我认为应包括以下几个方面呢：1，扎实的功底&amp;mdash;&amp;mdash;扎实掌握操作系统，数据结构等大学基本课程，鼓吹基础无用论的，必定是个三流程序员。2，学习心态&amp;mdash;&amp;mdash;对你所调用的，一定要有好奇心，尽可能花时间去了解API背后的东西，去了解系统框架是如何运作；对新的领域，一定要有好奇心，多尝试多学习，他山之石，可以攻玉。3，善于自学、总结、发问&amp;mdash;&amp;mdash;工作后没有人去手把手教你，只要自己刻苦专研，并总结成博客或者笔记之类的成果，才又提高；在遇到自己能力范围内解决不了的问题，要善于向牛人请求点播，而一针见血的问题往往也会收获一针见血的回答。&lt;/p&gt;
&lt;p&gt;　　举一个简单的例子来讨论素养1，需求如下：已经完成排序的1万条数据，现在需要取前5000条作为最终数据，考虑到数据量较大，如果是新建列表，遍历旧列表的5000条并重新建立引用，有(引用类型所占字节 * 5000)字节的空间上的浪费，而且这种方式显得比较笨拙。&lt;/p&gt;
&lt;p&gt;　　所以，略加思索后写出了以下代码：&lt;/p&gt;
&lt;div class="cnblogs_code"&gt;
&lt;pre&gt;List&amp;lt;Item&amp;gt; rankItems = &lt;span style="color: #0000ff;"&gt;new&lt;/span&gt; ArrayList&amp;lt;Item&amp;gt;&lt;span style="color: #000000;"&gt;();
&lt;/span&gt;&lt;span style="color: #008000;"&gt;//&lt;/span&gt;&lt;span style="color: #008000;"&gt; 生成数据+排序&lt;/span&gt;
&lt;span style="color: #000000;"&gt;...
&lt;/span&gt;&lt;span style="color: #0000ff;"&gt;while&lt;/span&gt; (rankItems.size() &amp;gt; 5000&lt;span style="color: #000000;"&gt;) {
    rankItems.remove(rankItems.size() &lt;/span&gt;- 1&lt;span style="color: #000000;"&gt;);
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　简单分析，对于ArrayList大家都不陌生，是以数组方式实现的链表，remove(index)方法实质上调用的是System.arraycopy()方法，源码如下：&lt;/p&gt;
&lt;div class="cnblogs_code"&gt;
&lt;pre&gt;    &lt;span style="color: #008000;"&gt;/**&lt;/span&gt;&lt;span style="color: #008000;"&gt;
     * Removes the object at the specified location from this list.
     *
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@param&lt;/span&gt;&lt;span style="color: #008000;"&gt; index
     *            the index of the object to remove.
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@return&lt;/span&gt;&lt;span style="color: #008000;"&gt; the removed object.
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@throws&lt;/span&gt;&lt;span style="color: #008000;"&gt; IndexOutOfBoundsException
     *             when {&lt;/span&gt;&lt;span style="color: #808080;"&gt;@code&lt;/span&gt;&lt;span style="color: #008000;"&gt; location &amp;lt; 0 || &amp;gt;= size()}
     &lt;/span&gt;&lt;span style="color: #008000;"&gt;*/&lt;/span&gt;&lt;span style="color: #000000;"&gt;
    @Override &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;public&lt;/span&gt; E remove(&lt;span style="color: #0000ff;"&gt;int&lt;/span&gt;&lt;span style="color: #000000;"&gt; index) {
        Object[] a &lt;/span&gt;=&lt;span style="color: #000000;"&gt; array;
        &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;int&lt;/span&gt; s =&lt;span style="color: #000000;"&gt; size;
        &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;if&lt;/span&gt; (index &amp;gt;=&lt;span style="color: #000000;"&gt; s) {
            throwIndexOutOfBoundsException(index, s);
        }
        @SuppressWarnings(&lt;/span&gt;"unchecked") E result =&lt;span style="color: #000000;"&gt; (E) a[index];
        System.arraycopy(a, index &lt;/span&gt;+ 1, a, index, --s -&lt;span style="color: #000000;"&gt; index);
        a[s] &lt;/span&gt;= &lt;span style="color: #0000ff;"&gt;null&lt;/span&gt;;  &lt;span style="color: #008000;"&gt;//&lt;/span&gt;&lt;span style="color: #008000;"&gt; Prevent memory leak&lt;/span&gt;
        size =&lt;span style="color: #000000;"&gt; s;
        modCount&lt;/span&gt;++&lt;span style="color: #000000;"&gt;;
        &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;return&lt;/span&gt;&lt;span style="color: #000000;"&gt; result;
    }&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　System.arraycopy()是native方法，调用的应该是C语言中的memcpy()，虽然copy的source地址和dest地址都是相同的，无需分配新内存，但是要经过5000次的内存IO读写才能删除ArrayList中的数据。究其原因是因为ArrayList的数组实现方式，不利于在指定位置做添加/删除操作，所以思考后有了以下代码：&lt;/p&gt;
&lt;div class="cnblogs_code"&gt;
&lt;pre&gt;List&amp;lt;Item&amp;gt; rankItems = &lt;span style="color: #0000ff;"&gt;new&lt;/span&gt; LinkedList&amp;lt;Item&amp;gt;&lt;span style="color: #000000;"&gt;();
&lt;/span&gt;&lt;span style="color: #008000;"&gt;//&lt;/span&gt;&lt;span style="color: #008000;"&gt; 生成数据+排序&lt;/span&gt;
&lt;span style="color: #000000;"&gt;...
&lt;/span&gt;&lt;span style="color: #0000ff;"&gt;while&lt;/span&gt; (rankItems.size() &amp;gt; 5000&lt;span style="color: #000000;"&gt;) {
    rankItems.remove(rankItems.size() &lt;/span&gt;- 1&lt;span style="color: #000000;"&gt;);
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　再分析LinkedList的删除效率，是否比ArrayList高了呢？LinkedList的remove(index)方法实现如下：&lt;/p&gt;
&lt;div class="cnblogs_code"&gt;
&lt;pre&gt;&lt;span style="color: #008000;"&gt;/**&lt;/span&gt;&lt;span style="color: #008000;"&gt;
     * Removes the object at the specified location from this {&lt;/span&gt;&lt;span style="color: #808080;"&gt;@code&lt;/span&gt;&lt;span style="color: #008000;"&gt; LinkedList}.
     *
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@param&lt;/span&gt;&lt;span style="color: #008000;"&gt; location
     *            the index of the object to remove
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@return&lt;/span&gt;&lt;span style="color: #008000;"&gt; the removed object
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@throws&lt;/span&gt;&lt;span style="color: #008000;"&gt; IndexOutOfBoundsException
     *             if {&lt;/span&gt;&lt;span style="color: #808080;"&gt;@code&lt;/span&gt;&lt;span style="color: #008000;"&gt; location &amp;lt; 0 || &amp;gt;= size()}
     &lt;/span&gt;&lt;span style="color: #008000;"&gt;*/&lt;/span&gt;&lt;span style="color: #000000;"&gt;
    @Override
    &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;public&lt;/span&gt; E remove(&lt;span style="color: #0000ff;"&gt;int&lt;/span&gt;&lt;span style="color: #000000;"&gt; location) {
        &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;if&lt;/span&gt; (0 &amp;lt;= location &amp;amp;&amp;amp; location &amp;lt;&lt;span style="color: #000000;"&gt; size) {
            Link&lt;/span&gt;&amp;lt;E&amp;gt; link =&lt;span style="color: #000000;"&gt; voidLink;
            &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;if&lt;/span&gt; (location &amp;lt; (size / 2&lt;span style="color: #000000;"&gt;)) {
                &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff;"&gt;int&lt;/span&gt; i = 0; i &amp;lt;= location; i++&lt;span style="color: #000000;"&gt;) {
                    link &lt;/span&gt;=&lt;span style="color: #000000;"&gt; link.next;
                }
            } &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;else&lt;/span&gt;&lt;span style="color: #000000;"&gt; {
                &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;for&lt;/span&gt; (&lt;span style="color: #0000ff;"&gt;int&lt;/span&gt; i = size; i &amp;gt; location; i--&lt;span style="color: #000000;"&gt;) {
                    link &lt;/span&gt;=&lt;span style="color: #000000;"&gt; link.previous;
                }
            }
            Link&lt;/span&gt;&amp;lt;E&amp;gt; previous =&lt;span style="color: #000000;"&gt; link.previous;
            Link&lt;/span&gt;&amp;lt;E&amp;gt; next =&lt;span style="color: #000000;"&gt; link.next;
            previous.next &lt;/span&gt;=&lt;span style="color: #000000;"&gt; next;
            next.previous &lt;/span&gt;=&lt;span style="color: #000000;"&gt; previous;
            size&lt;/span&gt;--&lt;span style="color: #000000;"&gt;;
            modCount&lt;/span&gt;++&lt;span style="color: #000000;"&gt;;
            &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;return&lt;/span&gt;&lt;span style="color: #000000;"&gt; link.data;
        }
        &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff;"&gt;new&lt;/span&gt;&lt;span style="color: #000000;"&gt; IndexOutOfBoundsException();
    }&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　LinkedList的删除操作很简单，只需要修改指定index对象其前后对象的引用即可，但是在指针移动到指定index之前，需要移动1/2个列表长度，效率并非最高，能否将移动的操作也简化掉呢？既然是已排好序的列表，每次删除都删除列表末尾的对象，那我们可以使用LinkedList提供的removeLast()方法，代码如下：&lt;/p&gt;
&lt;div class="cnblogs_code"&gt;
&lt;pre&gt;List&amp;lt;Item&amp;gt; rankItems = &lt;span style="color: #0000ff;"&gt;new&lt;/span&gt; LinkedList&amp;lt;Item&amp;gt;&lt;span style="color: #000000;"&gt;();
&lt;/span&gt;&lt;span style="color: #008000;"&gt;//&lt;/span&gt;&lt;span style="color: #008000;"&gt; 生成数据+排序&lt;/span&gt;
&lt;span style="color: #000000;"&gt;...
&lt;/span&gt;&lt;span style="color: #0000ff;"&gt;while&lt;/span&gt; (rankItems.size() &amp;gt; 5000&lt;span style="color: #000000;"&gt;) {
    rankItems.removeLast();
}&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　分析removeLast()的效率，LinkedList的removeLast()方法实现如下：&lt;/p&gt;
&lt;div class="cnblogs_code"&gt;
&lt;pre&gt;&lt;span style="color: #008000;"&gt;/**&lt;/span&gt;&lt;span style="color: #008000;"&gt;
     * Removes the last object from this {&lt;/span&gt;&lt;span style="color: #808080;"&gt;@code&lt;/span&gt;&lt;span style="color: #008000;"&gt; LinkedList}.
     *
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@return&lt;/span&gt;&lt;span style="color: #008000;"&gt; the removed object.
     * &lt;/span&gt;&lt;span style="color: #808080;"&gt;@throws&lt;/span&gt;&lt;span style="color: #008000;"&gt; NoSuchElementException
     *             if this {&lt;/span&gt;&lt;span style="color: #808080;"&gt;@code&lt;/span&gt;&lt;span style="color: #008000;"&gt; LinkedList} is empty.
     &lt;/span&gt;&lt;span style="color: #008000;"&gt;*/&lt;/span&gt;
    &lt;span style="color: #0000ff;"&gt;public&lt;/span&gt;&lt;span style="color: #000000;"&gt; E removeLast() {
        Link&lt;/span&gt;&amp;lt;E&amp;gt; last =&lt;span style="color: #000000;"&gt; voidLink.previous;
        &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;if&lt;/span&gt; (last !=&lt;span style="color: #000000;"&gt; voidLink) {
            Link&lt;/span&gt;&amp;lt;E&amp;gt; previous =&lt;span style="color: #000000;"&gt; last.previous;
            voidLink.previous &lt;/span&gt;=&lt;span style="color: #000000;"&gt; previous;
            previous.next &lt;/span&gt;=&lt;span style="color: #000000;"&gt; voidLink;
            size&lt;/span&gt;--&lt;span style="color: #000000;"&gt;;
            modCount&lt;/span&gt;++&lt;span style="color: #000000;"&gt;;
            &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;return&lt;/span&gt;&lt;span style="color: #000000;"&gt; last.data;
        }
        &lt;/span&gt;&lt;span style="color: #0000ff;"&gt;throw&lt;/span&gt; &lt;span style="color: #0000ff;"&gt;new&lt;/span&gt;&lt;span style="color: #000000;"&gt; NoSuchElementException();
    }&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;　　LinkedList的removeLast()方法没有移动指针的操作，只需要借助于列表尾的voidLink，即可完成对列表尾部对象的删除，效率上较高。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;结束语：一个程序员一定要对自己的代码负责到底，优化，不仅对业务有所提升，更多的是在思考优化的过程中对提升自己的功力很有帮助。最近闲时时常思考自己的职业规划与出路，迷茫之中终有坚定，坚持做一个好的程序员，一定会有美好的明天！&lt;/p&gt;&lt;/div&gt;&lt;div id="MySignature"&gt;&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="blog_post_info_block"&gt;
&lt;div id="BlogPostCategory"&gt;&lt;/div&gt;
&lt;div id="EntryTag"&gt;&lt;/div&gt;
&lt;div id="blog_post_info"&gt;
&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="post_next_prev"&gt;&lt;/div&gt;
&lt;/div&gt;


		&lt;/div&gt;
		&lt;div class="postDesc"&gt;posted @ &lt;span id="post-date"&gt;2014-09-15 18:26&lt;/span&gt; &lt;a href='http://www.cnblogs.com/zealotrouge/'&gt;热气球&lt;/a&gt; 阅读(&lt;span id="post_view_count"&gt;...&lt;/span&gt;) 评论(&lt;span id="post_comment_count"&gt;...&lt;/span&gt;)  &lt;a href="http://i.cnblogs.com/EditPosts.aspx?postid=3890359" rel="nofollow"&gt;编辑&lt;/a&gt; &lt;a href="#" onclick="AddToWz(3890359);return false;"&gt;收藏&lt;/a&gt;&lt;/div&gt;
	&lt;/div&gt;
	&lt;script type="text/javascript"&gt;var allowComments=true,isLogined=false,cb_blogId=115342,cb_entryId=3890359,cb_blogApp=currentBlogApp,cb_blogUserGuid='44b4c4a5-be7f-e111-aa3f-842b2b196315',cb_entryCreatedDate='2014/9/15 18:26:00';loadViewCount(cb_entryId);&lt;/script&gt;
	
&lt;/div&gt;
&lt;!--end: topics 文章、评论容器--&gt;
&lt;a name="!comments"&gt;&lt;/a&gt;&lt;div id="blog-comments-placeholder"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var commentManager = new blogCommentManager();commentManager.renderComments(0);&lt;/script&gt;
&lt;div id="comment_form" class="commentform"&gt;
&lt;a name="commentform"&gt;&lt;/a&gt;
&lt;div id="divCommentShow"&gt;&lt;/div&gt;
&lt;div id="comment_nav"&gt;&lt;span id="span_refresh_tips"&gt;&lt;/span&gt;&lt;a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();"&gt;刷新评论&lt;/a&gt;&lt;a href="#" onclick="return RefreshPage();"&gt;刷新页面&lt;/a&gt;&lt;a href="#top"&gt;返回顶部&lt;/a&gt;&lt;/div&gt;
&lt;div id="comment_form_container"&gt;&lt;/div&gt;
&lt;div class="ad_text_commentbox" id="ad_text_under_commentbox"&gt;&lt;/div&gt;
&lt;div id="site_nav_under"&gt;&lt;a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园"&gt;博客园首页&lt;/a&gt;&lt;a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区"&gt;博问&lt;/a&gt;&lt;a href="http://news.cnblogs.com/" target="_blank" title="IT新闻"&gt;新闻&lt;/a&gt;&lt;a href="http://home.cnblogs.com/ing/" target="_blank"&gt;闪存&lt;/a&gt;&lt;a href="http://job.cnblogs.com/" target="_blank"&gt;程序员招聘&lt;/a&gt;&lt;a href="http://kb.cnblogs.com/" target="_blank"&gt;知识库&lt;/a&gt;&lt;/div&gt;
&lt;div id="opt_under_post"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    var enableGoogleAd = canShowAdsense(); var googletag = googletag || {}; googletag.cmd = googletag.cmd || [];
    fixPostBodyFormat();
&lt;/script&gt;
&lt;div id="ad_under_post_holder"&gt;
&lt;script type='text/javascript'&gt;
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
    })();
&lt;/script&gt;
&lt;script type='text/javascript'&gt;
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function () {
                googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1346480159711-0').addService(googletag.pubads());
                googletag.pubads().enableSingleRequest();
                googletag.enableServices();
            });
        };
    } catch (e) { }
&lt;/script&gt;
&lt;div id="google_ad_c1" class="c_ad_block"&gt;
    &lt;div id='div-gpt-ad-1346480159711-0' style='width:300px; height:250px;'&gt;
    &lt;script type='text/javascript'&gt;
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1346480159711-0'); });            
            } else {
                $('#div-gpt-ad-1346480159711-0').hide();
            }
    } catch (e) { }
    &lt;/script&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="blog_news_kb"&gt;&lt;/div&gt;
&lt;div id="HistoryToday" class="c_ad_block"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
&lt;/script&gt;
&lt;/div&gt;

	&lt;/div&gt;&lt;!--end: forFlow --&gt;
	&lt;/div&gt;&lt;!--end: mainContent 主体内容容器--&gt;

	&lt;div id="sideBar"&gt;
		&lt;div id="sideBarMain"&gt;
		&lt;div id="calendar"&gt;&lt;div id="blog-calendar" style="display:none"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogDefaultCalendar();&lt;/script&gt;&lt;/div&gt;
			
&lt;!--done--&gt;
&lt;div class="newsItem"&gt;
&lt;h3 class="catListTitle"&gt;公告&lt;/h3&gt;
	&lt;div id="blog-news"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogNews();&lt;/script&gt;
&lt;/div&gt;
			
			
			&lt;div id="leftcontentcontainer"&gt;
				&lt;div id="blog-sidecolumn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogSideColumn();&lt;/script&gt;
			&lt;/div&gt;
			
		&lt;/div&gt;&lt;!--end: sideBarMain --&gt;
	&lt;/div&gt;&lt;!--end: sideBar 侧边栏容器 --&gt;
	&lt;div class="clear"&gt;&lt;/div&gt;
	&lt;/div&gt;&lt;!--end: main --&gt;
	&lt;div class="clear"&gt;&lt;/div&gt;
	&lt;div id="footer"&gt;
		
&lt;!--done--&gt;
Copyright &amp;copy;2014 热气球
	&lt;/div&gt;&lt;!--end: footer --&gt;
&lt;/div&gt;&lt;!--end: home 自定义的最大容器 --&gt;
&lt;/body&gt;
&lt;/html&gt;
</Html>
	<HtmlMetas i:nil="true" />
	<HtmlTitle i:nil="true" />
	<IsDefault>false</IsDefault>
	<Layout i:nil="true" />
	<Name>-zealotrouge-p-3890359.html</Name>
	<OutputCache i:nil="true" />
	<PageContents xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
	<Plugins xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<Published>false</Published>
	<RequireHttps>false</RequireHttps>
	<Routes>
		<PageRoute>
			<Defaults xmlns:d4p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
			<Identifier>/zealotrouge/p/3890359.html</Identifier>
			<RoutePath i:nil="true" />
		</PageRoute>
	</Routes>
	<Scripts i:nil="true" />
	<Site>
		<AbsoluteName xmlns="Ovaldi.Core.Models">Cnblogs</AbsoluteName>
	</Site>
	<Styles i:nil="true" />
	<UUID>-zealotrouge-p-3890359.html</UUID>
</Page>