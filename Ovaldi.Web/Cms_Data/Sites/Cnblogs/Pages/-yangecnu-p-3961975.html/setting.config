<?xml version="1.0" encoding="utf-8"?>
<Page xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/Ovaldi.Core.Models">
	<AbsoluteName>-yangecnu-p-3961975.html</AbsoluteName>
	<CustomFields xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<EnableScript>true</EnableScript>
	<EnableTheming>true</EnableTheming>
	<Html>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;title&gt;使用ServiceStack构建Web服务 - yangecnu - 博客园&lt;/title&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/bundles/blog-common.css"&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/blog/customcss/62045.css"&gt;
&lt;link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/yangecnu/rss"&gt;
&lt;link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/yangecnu/rsd.xml"&gt;
&lt;link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/yangecnu/wlwmanifest.xml"&gt;
&lt;script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"&gt;&lt;/script&gt;  
&lt;script type="text/javascript"&gt;var currentBlogApp = 'yangecnu', cb_enable_mathjax=false;&lt;/script&gt;
&lt;script src="/preview~Cnblogs/Scripts/bundles/blog-common.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a name="top"&gt;&lt;/a&gt;

&lt;div id="home"&gt;
&lt;div id="header"&gt;
	&lt;div id="blogTitle"&gt;
		
&lt;!--done--&gt;
&lt;div class="title"&gt;&lt;a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/yangecnu/"&gt;寒江独钓&lt;/a&gt;&lt;/div&gt;
&lt;div class="subtitle"&gt;不见五陵豪杰墓，无花无酒锄作田&lt;/div&gt;



		
	&lt;/div&gt;&lt;!--end: blogTitle 博客的标题和副标题 --&gt;
	&lt;div id="navigator"&gt;
		
&lt;ul id="navList"&gt;
&lt;li id="nav_sitehome"&gt;&lt;a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/"&gt;博客园&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_myhome"&gt;&lt;a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/yangecnu/"&gt;首页&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_q"&gt;&lt;a class="menu" href="http://q.cnblogs.com/"&gt;博问&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_ing"&gt;&lt;a class="menu" href="http://home.cnblogs.com/ing/"&gt;闪存&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_newpost"&gt;&lt;a id="MyLinks1_NewPostLink" class="menu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1"&gt;新随笔&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_contact"&gt;&lt;a id="MyLinks1_ContactLink" class="menu" rel="nofollow" href="http://space.cnblogs.com/msg/send/yangecnu"&gt;联系&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_rss"&gt;&lt;a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/yangecnu/rss"&gt;订阅&lt;/a&gt;
&lt;!--&lt;a id="MyLinks1_XMLLink" class="aHeaderXML" href="http://www.cnblogs.com/yangecnu/rss"&gt;&lt;img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /&gt;&lt;/a&gt;--&gt;&lt;/li&gt;
&lt;li id="nav_admin"&gt;&lt;a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/"&gt;管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

		&lt;div class="blogStats"&gt;
			
			
&lt;!--done--&gt;
随笔-92&amp;nbsp;
文章-0&amp;nbsp;
评论-1478&amp;nbsp;

			
		&lt;/div&gt;&lt;!--end: blogStats --&gt;
	&lt;/div&gt;&lt;!--end: navigator 博客导航栏 --&gt;
&lt;/div&gt;&lt;!--end: header 头部 --&gt;
&lt;div id="main"&gt;
	&lt;div id="mainContent"&gt;
	&lt;div class="forFlow"&gt;
		

&lt;!--done--&gt;
&lt;div id="topics"&gt;
	&lt;div class="post"&gt;
		&lt;h1 class="postTitle"&gt;
			&lt;a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/yangecnu/p/Introduce-ServiceStack.html"&gt;使用ServiceStack构建Web服务&lt;/a&gt;
		&lt;/h1&gt;
		&lt;div class="clear"&gt;&lt;/div&gt;
		&lt;div class="postBody"&gt;
			&lt;div id="cnblogs_post_body"&gt;&lt;p&gt;提到构建WebService服务，大家肯定第一个想到的是使用WCF，因为简单快捷嘛。首先要说明的是，本人对WCF不太了解，但是想快速建立一个WebService，于是看到了MSDN上的这一篇文章 &lt;a href="http://msdn.microsoft.com/zh-cn/magazine/dn342871.aspx"&gt;Building Cross-Platform Web Services with ServiceStack&lt;/a&gt;，所以这里简要介绍一下如何使用ServiceStack快速建立一个WebService服务。&lt;/p&gt;
&lt;p&gt;当然，在开始之前，首先要说明一下ServiceStack是个什么东西。 在国内用ServiceStack的似乎很少，大部分都是WCF或者ASP.NET WebAPI，唯一接触ServiceStack的可能是在C# 中调用Redis的时候，有个&lt;a href="https://github.com/ServiceStack/ServiceStack.Redis"&gt;ServiceStack.Redis&lt;/a&gt;，之前还写过一篇&lt;a href="http://www.cnblogs.com/yangecnu/p/Introduct-Redis-in-DotNET.html"&gt; .NET中使用Redis&lt;/a&gt; 的拙文。这个ServiceStack.Redis其实就是ServiceStack的一个组件，专门用来跟Redis进行交互的。&lt;/p&gt;
&lt;h1&gt;&lt;span style="font-size: x-large;"&gt;一 关于WebService &lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;在谈论ServiceStack之前，先看看构成一个WebService的基本框架：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090119591849664.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="Print" src="http://images.cnitblog.com/blog/94031/201409/090120011689792.png" alt="Print" width="287" height="337" border="0"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;服务层就是定义WebService接口的地方，这一层也是客户端使用WebService唯一需要与之交互的一层。&lt;/p&gt;
&lt;p&gt;业务层通常包含有大量的业务逻辑。他也是实现接口层定义的接口的地方，也是保持服务层的轻量以及关注服务端客户端的契约以及通讯的地方。&lt;/p&gt;
&lt;p&gt;数据层通常就是封装数据访问方法并给业务层提供抽象数据模型。&lt;/p&gt;
&lt;p&gt;现在我们来看Service这一层。一些WebService使用远程过程调用的方法来实现(RPC)，比如会定义如下函数调用：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;IService
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: blue;"&gt;string &lt;/span&gt;&lt;span style="color: black;"&gt;DoSomething(&lt;/span&gt;&lt;span style="color: blue;"&gt;int &lt;/span&gt;&lt;span style="color: black;"&gt;input);
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;这种RPC的方式使得服务不能很好的应对变化。比如，在上面的代码中，如果后续版本的接口需要接受两个参数来执行DoSomething方法，或者说除了返回一个string外还需要返回其他信息。如果在原接口上修改的话，就会使得老版本的客户端无法使用。当然，我们可以创建一个平行的DoSomething_v2来接受两个参数。但是随着时间的迁移，我们的接口中会充斥着越来越多这样的定义，不管是新用户还是老用户都会感到困惑。&lt;/p&gt;
&lt;p&gt;面对这种情况，可以使用数据传输对象(DTO) 来定义前面的接口中的相关参数。上面的RPC方式转换为对应的DTO模型如下：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;DoSomethingRequest
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public int &lt;/span&gt;&lt;span style="color: black;"&gt;Input { &lt;/span&gt;&lt;span style="color: blue;"&gt;get&lt;/span&gt;&lt;span style="color: black;"&gt;; &lt;/span&gt;&lt;span style="color: blue;"&gt;set&lt;/span&gt;&lt;span style="color: black;"&gt;; }
}
&lt;/span&gt;&lt;span style="color: blue;"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;DoSomethingResponse
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public string &lt;/span&gt;&lt;span style="color: black;"&gt;Result { &lt;/span&gt;&lt;span style="color: blue;"&gt;get&lt;/span&gt;&lt;span style="color: black;"&gt;; &lt;/span&gt;&lt;span style="color: blue;"&gt;set&lt;/span&gt;&lt;span style="color: black;"&gt;; }
}
&lt;/span&gt;&lt;span style="color: blue;"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;IService
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;DoSomethingResponse &lt;/span&gt;&lt;span style="color: black;"&gt;DoSomething(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;DoSomethingRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request);
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;每个服务接受一个DTO请求参数，返回一个DTO响应。在请求和相应的DTO对象中添加字段，不会破坏旧的客户端。&lt;/p&gt;
&lt;p&gt;在WCF中RPC和DTO风格的WebService均支持，但是在ServiceStack中仅支持DTO风格。ServiceStack为了减少繁琐和注重接口设计从而仅拥抱的DTO风格的远程 WebService接口。 这是了解 ServiceStack的关键，也是ServiceStack框架的设计原则。&lt;/p&gt;
&lt;p&gt;了解了ServiceStack的设计理念后，来看看ServiceStack是什么。&lt;/p&gt;
&lt;h1&gt;&lt;span style="font-size: x-large;"&gt;二 ServiceStack是什么&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;ServiceStack是一个开源的十分流行的WebService框架，引用其&lt;a href="https://github.com/ServiceStack/ServiceStack"&gt;官网&lt;/a&gt;的介绍：&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Service Stack is a high-performance .NET web services platform that simplifies the development of high-performance REST (JSON, XML, JSV, HTML, MsgPack, ProtoBuf, CSV) and WCF SOAP &lt;a href="https://github.com/ServiceStack/ServiceStack/wiki/Service-Stack-Web-Services"&gt;Web Services&lt;/a&gt;.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;&amp;ldquo;ServiceStack是一个高性能的.NET Web Service 平台，他能够简化开发高性能的REST (支持JSON,XML,JSV,HTML,MsgPack,ProtoBuf,CSV等消息格式)以及WCF SOAP风格的WebService&amp;rdquo;。&lt;/p&gt;
&lt;p&gt;在其&lt;a href="https://servicestack.net/"&gt;主页&lt;/a&gt;上也有一篇名为&lt;a href="https://www.slideshare.net/slideshow/embed_code/14819151"&gt;What is the ServiceStack&lt;/a&gt;的介绍。建议您直接看，这里从里面截取了几张图：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090120042316789.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="more than service" src="http://images.cnitblog.com/blog/94031/201409/090120348872023.png" alt="more than service" width="1276" height="754" border="0"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到ServiceStack除了在其底层是一个精简的WebService框架之外，在其上还有与之相关的一些组件，比如号称.NET 上最快的JSON序列化工具，.NET中流行的Redis访问模块，轻量级快速Orm框架OrmLite等诸多功能。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090120383098677.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="what is service stack" src="http://images.cnitblog.com/blog/94031/201409/090120427311161.png" alt="what is service stack" width="708" height="616" border="0"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到这些组件基本提供了一个WebService框架必需的一些功能。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090121062622871.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="Visualizing ServiceStack" src="http://images.cnitblog.com/blog/94031/201409/090121548401966.png" alt="Visualizing ServiceStack" width="1274" height="751" border="0"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在内部实现上ServiceStack建立在原生的ASP.NET IHttpHandler之上，他能够允许在.NET Framework和Mono之上。&lt;/p&gt;
&lt;p&gt;下面来看如何使用ServiceStack建立一个WebService：&lt;/p&gt;
&lt;h1&gt;&lt;span style="font-size: x-large;"&gt;三 使用ServiceStack&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;要创建服务，首先要定义接口。这里以一个售票系统为例来说明如何使用ServiceStack来创建服务:&lt;/p&gt;
&lt;h2&gt;创建服务接口层&lt;/h2&gt;
&lt;p&gt;首先新建一个TicketSystem.ServiceContract的类库，我们定义DTO对象。必需要有一个Ticket实体类：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public int &lt;/span&gt;&lt;span style="color: black;"&gt;TicketId { &lt;/span&gt;&lt;span style="color: blue;"&gt;get&lt;/span&gt;&lt;span style="color: black;"&gt;; &lt;/span&gt;&lt;span style="color: blue;"&gt;set&lt;/span&gt;&lt;span style="color: black;"&gt;; }
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public int &lt;/span&gt;&lt;span style="color: black;"&gt;TableNumber { &lt;/span&gt;&lt;span style="color: blue;"&gt;get&lt;/span&gt;&lt;span style="color: black;"&gt;; &lt;/span&gt;&lt;span style="color: blue;"&gt;set&lt;/span&gt;&lt;span style="color: black;"&gt;; }
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public int &lt;/span&gt;&lt;span style="color: black;"&gt;ServerId { &lt;/span&gt;&lt;span style="color: blue;"&gt;get&lt;/span&gt;&lt;span style="color: black;"&gt;; &lt;/span&gt;&lt;span style="color: blue;"&gt;set&lt;/span&gt;&lt;span style="color: black;"&gt;; }
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;List&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Order&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;gt; Orders { &lt;/span&gt;&lt;span style="color: blue;"&gt;get&lt;/span&gt;&lt;span style="color: black;"&gt;; &lt;/span&gt;&lt;span style="color: blue;"&gt;set&lt;/span&gt;&lt;span style="color: black;"&gt;; }
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;DateTime &lt;/span&gt;&lt;span style="color: black;"&gt;Timestamp { &lt;/span&gt;&lt;span style="color: blue;"&gt;get&lt;/span&gt;&lt;span style="color: black;"&gt;; &lt;/span&gt;&lt;span style="color: blue;"&gt;set&lt;/span&gt;&lt;span style="color: black;"&gt;; }
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;在WCF中需要在实体类和字段上面添加DataContract和DataMember来表示序列化时需要的字段，如果没有添加这些标签，在序列化的时候就会忽略。&lt;/p&gt;
&lt;p&gt;而在ServiceStack中，这些标记都不需要，ServiceStack会序列化所有的Plain Old CLR Objects（POCOs）,并且这些对象对客户端都可见。&lt;/p&gt;
&lt;p&gt;然后开始定义Service中需要用到的对外提供服务的接口：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;ITicketService
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;List&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;gt; Any(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;GetAllTicketsInQueueRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request);

    &lt;/span&gt;&lt;span style="color: blue;"&gt;void &lt;/span&gt;&lt;span style="color: black;"&gt;Any(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;QueueTicketRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request);

    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket &lt;/span&gt;&lt;span style="color: black;"&gt;Any(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;PullTicketRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request);
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;在ITickertService中，我们定义了三个操作，第一次看到这样的操作可能有些奇怪，因为方法名称都一样。这是ServiceStack和WCF不一样的地方。在WCF中以上接口可能是这样的：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: black;"&gt;[ServiceContract]
&lt;/span&gt;&lt;span style="color: blue;"&gt;public interface &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;ITicketService
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    [OperationContract]
    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;List&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;gt; GetAllTicketsInQueue(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;GetAllTicketsInQueueRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request);
    [OperationContract]
    &lt;/span&gt;&lt;span style="color: blue;"&gt;void &lt;/span&gt;&lt;span style="color: black;"&gt;QueueTicket(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;QueueTicketRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request);
    [OperationContract]
    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket &lt;/span&gt;&lt;span style="color: black;"&gt;PullTicket(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;PullTicketRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request);
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;WCF中接口需要使用ServiceContract来表明，其中的方法需要使用OperationContract来标记。方法的名称就是服务的名称。&lt;/p&gt;
&lt;p&gt;ServiceStack中的服务方法名为Any，Get以及Post，这也是ServiceStack支持的请求类型，Any表示服务可以通过HTTP Get和HTTP Post两种方式调用。这强化和简化了RESTFull风格的WebService的实现。只需要在这些方法上添加爱[Route(&amp;hellip;)]属性即可。在ServiceStack中，方法和方法之间的区别是通过服务的参数及请求对象Request DTO来区分的，而不是像WCF中通过方法名称来区分。这就表示一个请求DTO对象不能在ServiceStack的多个Service中复用。&lt;/p&gt;
&lt;h2&gt;创建服务端&lt;/h2&gt;
&lt;p&gt;有了服务接口层之后，需要编写服务端以实现这些逻辑，也就是前面定义的ITicketService接口。首先创建名为ServiceStackServer的空的ASP.NET 应用程序，然后新建TicketService类，是该类实现ITicketService接口并继承自Service类。Service类是ServiceStack中的，可以通过NuGet来安装和引用ServiceStack相关类库：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090122029658316.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="Managet NuGet Packages" src="http://images.cnitblog.com/blog/94031/201409/090122079342997.png" alt="Managet NuGet Packages" width="1131" height="597" border="0"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现后TicketService类如下：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketService &lt;/span&gt;&lt;span style="color: black;"&gt;: &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Service&lt;/span&gt;&lt;span style="color: black;"&gt;, &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;ITicketService
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: blue;"&gt;private static readonly &lt;/span&gt;&lt;span style="color: black;"&gt;TicketSystem.TicketProcessor.&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketProcessor
        &lt;/span&gt;&lt;span style="color: black;"&gt;_ticketProcessor = &lt;/span&gt;&lt;span style="color: blue;"&gt;new &lt;/span&gt;&lt;span style="color: black;"&gt;TicketSystem.TicketProcessor.&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketProcessor&lt;/span&gt;&lt;span style="color: black;"&gt;();

    &lt;/span&gt;&lt;span style="color: blue;"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;List&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;gt; Any(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;GetAllTicketsInQueueRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request)
    {
        &lt;/span&gt;&lt;span style="color: blue;"&gt;return &lt;/span&gt;&lt;span style="color: black;"&gt;_ticketProcessor.GetTicketsInQueue()
            .Select(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketTranslator&lt;/span&gt;&lt;span style="color: black;"&gt;.TranslateTicket).ToList();
    }

    &lt;/span&gt;&lt;span style="color: blue;"&gt;public void &lt;/span&gt;&lt;span style="color: black;"&gt;Any(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;QueueTicketRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request)
    {
        _ticketProcessor.QueueTicket(
            &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketTranslator&lt;/span&gt;&lt;span style="color: black;"&gt;.TranslateTicket(request.Ticket));
    }

    &lt;/span&gt;&lt;span style="color: blue;"&gt;public &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket &lt;/span&gt;&lt;span style="color: black;"&gt;Any(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;PullTicketRequest &lt;/span&gt;&lt;span style="color: black;"&gt;request)
    {
        TicketSystem.TicketProcessor.&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket &lt;/span&gt;&lt;span style="color: black;"&gt;nextTicket =
            _ticketProcessor.PullTicket();

        &lt;/span&gt;&lt;span style="color: blue;"&gt;if &lt;/span&gt;&lt;span style="color: black;"&gt;(nextTicket != &lt;/span&gt;&lt;span style="color: blue;"&gt;null&lt;/span&gt;&lt;span style="color: black;"&gt;)
        {
            &lt;/span&gt;&lt;span style="color: blue;"&gt;return &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketTranslator&lt;/span&gt;&lt;span style="color: black;"&gt;.TranslateTicket(nextTicket);
        }

        &lt;/span&gt;&lt;span style="color: blue;"&gt;return null&lt;/span&gt;&lt;span style="color: black;"&gt;;
    }
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;这里面我们定义了一个私有了TicketProcessor 变量，接口中的所有方法都通过该类实现，在接口对象到该方法的调用中，我们对实体进行了转换。该对象在其他程序集中定义，这样能保证服务端代码简洁。&lt;/p&gt;
&lt;p&gt;有了服务端之后，需要把服务端Host起来对外提供服务，ServiceStack提供了通过IIS，Self-Host等多种形式。因为我们之前创建的ASP.NET程序，所以，只需要再添加一个Global.asax文件，然后在启动的事件Application_Start中初始化即可。&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;protected void &lt;/span&gt;&lt;span style="color: black;"&gt;Application_Start(&lt;/span&gt;&lt;span style="color: blue;"&gt;object &lt;/span&gt;&lt;span style="color: black;"&gt;sender, &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;EventArgs &lt;/span&gt;&lt;span style="color: black;"&gt;e)
{
    &lt;/span&gt;&lt;span style="color: green;"&gt;//Initialize your web service on startup.
    &lt;/span&gt;&lt;span style="color: blue;"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketServiceHost&lt;/span&gt;&lt;span style="color: black;"&gt;().Init();
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketServiceHost &lt;/span&gt;&lt;span style="color: black;"&gt;: &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;AppHostBase
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: green;"&gt;//Register your web service with ServiceStack.
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public &lt;/span&gt;&lt;span style="color: black;"&gt;TicketServiceHost() 
        : &lt;/span&gt;&lt;span style="color: blue;"&gt;base&lt;/span&gt;&lt;span style="color: black;"&gt;(&lt;/span&gt;&lt;span style="color: #a31515;"&gt;"Ticket Service"&lt;/span&gt;&lt;span style="color: black;"&gt;, &lt;/span&gt;&lt;span style="color: blue;"&gt;typeof&lt;/span&gt;&lt;span style="color: black;"&gt;(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketService&lt;/span&gt;&lt;span style="color: black;"&gt;).Assembly) 
    { }

    &lt;/span&gt;&lt;span style="color: blue;"&gt;public override void &lt;/span&gt;&lt;span style="color: black;"&gt;Configure(Funq.&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Container &lt;/span&gt;&lt;span style="color: black;"&gt;container)
    {
        &lt;/span&gt;&lt;span style="color: green;"&gt;//Register any dependencies your services use here.
    &lt;/span&gt;&lt;span style="color: black;"&gt;}
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;只需要实现ApphostBase基类，提供服务显示名称，以及实现了Service接口的服务所在的程序集即可。&lt;/p&gt;
&lt;p&gt;当然也可以通过控制台应用程序来Host我们的WebService，这时TicketServiceHost需要实现AppSelfHostBase，实现如下：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;public class &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketServiceHost &lt;/span&gt;&lt;span style="color: black;"&gt;: &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;AppSelfHostBase
&lt;/span&gt;&lt;span style="color: black;"&gt;{
    &lt;/span&gt;&lt;span style="color: gray;"&gt;/// &amp;lt;summary&amp;gt;
    /// &lt;/span&gt;&lt;span style="color: green;"&gt;Default constructor.
    &lt;/span&gt;&lt;span style="color: gray;"&gt;/// &lt;/span&gt;&lt;span style="color: green;"&gt;Base constructor requires a name and assembly to locate web service classes. 
    &lt;/span&gt;&lt;span style="color: gray;"&gt;/// &amp;lt;/summary&amp;gt;
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public &lt;/span&gt;&lt;span style="color: black;"&gt;TicketServiceHost()
        : &lt;/span&gt;&lt;span style="color: blue;"&gt;base&lt;/span&gt;&lt;span style="color: black;"&gt;(&lt;/span&gt;&lt;span style="color: #a31515;"&gt;"WebApplication1"&lt;/span&gt;&lt;span style="color: black;"&gt;, &lt;/span&gt;&lt;span style="color: blue;"&gt;typeof&lt;/span&gt;&lt;span style="color: black;"&gt;(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketService&lt;/span&gt;&lt;span style="color: black;"&gt;).Assembly)
    {

    }

    &lt;/span&gt;&lt;span style="color: gray;"&gt;/// &amp;lt;summary&amp;gt;
    /// &lt;/span&gt;&lt;span style="color: green;"&gt;Application specific configuration
    &lt;/span&gt;&lt;span style="color: gray;"&gt;/// &lt;/span&gt;&lt;span style="color: green;"&gt;This method should initialize any IoC resources utilized by your web service classes.
    &lt;/span&gt;&lt;span style="color: gray;"&gt;/// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name="container"&amp;gt;&amp;lt;/param&amp;gt;
    &lt;/span&gt;&lt;span style="color: blue;"&gt;public override void &lt;/span&gt;&lt;span style="color: black;"&gt;Configure(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Container &lt;/span&gt;&lt;span style="color: black;"&gt;container)
    {
        &lt;/span&gt;&lt;span style="color: green;"&gt;//Config examples
        //this.AddPlugin(new PostmanFeature());
        //this.AddPlugin(new CorsFeature());
    &lt;/span&gt;&lt;span style="color: black;"&gt;}
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;然后在Main函数中，启动即可：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;static void &lt;/span&gt;&lt;span style="color: black;"&gt;Main(&lt;/span&gt;&lt;span style="color: blue;"&gt;string&lt;/span&gt;&lt;span style="color: black;"&gt;[] args)
{
    &lt;/span&gt;&lt;span style="color: blue;"&gt;var &lt;/span&gt;&lt;span style="color: black;"&gt;listeningOn = args.Length == 0 ? &lt;/span&gt;&lt;span style="color: #a31515;"&gt;"http://*:1337/" &lt;/span&gt;&lt;span style="color: black;"&gt;: args[0];
    &lt;/span&gt;&lt;span style="color: blue;"&gt;var &lt;/span&gt;&lt;span style="color: black;"&gt;appHost = &lt;/span&gt;&lt;span style="color: blue;"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;TicketServiceHost&lt;/span&gt;&lt;span style="color: black;"&gt;()
        .Init()
        .Start(listeningOn);

    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Console&lt;/span&gt;&lt;span style="color: black;"&gt;.WriteLine(&lt;/span&gt;&lt;span style="color: #a31515;"&gt;"AppHost Created at {0}, listening on {1}"&lt;/span&gt;&lt;span style="color: black;"&gt;,
        &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;DateTime&lt;/span&gt;&lt;span style="color: black;"&gt;.Now, listeningOn);

    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Console&lt;/span&gt;&lt;span style="color: black;"&gt;.ReadKey();
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;现在，我们运行前面创建的ASP.NET或者运行Console托管的TicketServiceHost， 在浏览器中访问&lt;a href="http://localhost:1337/"&gt;http://localhost:1337/&lt;/a&gt;即可看到我们定义好的服务：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090122098563910.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="AppSelfHost" src="http://images.cnitblog.com/blog/94031/201409/090122103719053.png" alt="AppSelfHost" width="676" height="92" border="0"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090122129344136.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="service page" src="http://images.cnitblog.com/blog/94031/201409/090122148718278.png" alt="service page" width="935" height="667" border="0"&gt;&lt;/a&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;服务客户端&lt;/h2&gt;
&lt;p&gt;服务端创建和托管好之后， 服务使用者就可以直接编写HttpWebRequest对象对这些服务通过Get或者Post方式进行直接访问了。&lt;/p&gt;
&lt;p&gt;除此之外，ServiceStack也内置了一些便捷访问的客户端，这些对象位于ServiceStack.ServiceClient.Web命名空间中。所有的内置的客户端都实现了ServiceStack.Service.IServiceClient 放，这些支持REST的客户端都实现了ServiceStack.Service.IRestClient.这些客户端对象包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JsonServiceClient&lt;/li&gt;
&lt;li&gt;JsvServiceClient&lt;/li&gt;
&lt;li&gt;XmlServiceClient&lt;/li&gt;
&lt;li&gt;MsgPackServiceClient&lt;/li&gt;
&lt;li&gt;ProtoBufServiceClient&lt;/li&gt;
&lt;li&gt;Soap11ServiceClient&lt;/li&gt;
&lt;li&gt;Soap12ServiceClient&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从名称可以看出，这几种不同之处在于支持的序列化和反序列化格式不同。因为他们实现的是一系列相同的接口，所以他们的用法相同，也可以相互替换。&lt;/p&gt;
&lt;p&gt;这里我们不演示如何通过HttpWebRequest像请求普通的网页那样请求我们之前托管好的WebService，现在假设我们有一个Console程序需要使用WebService程序。只需要新建一个ServiceStack的Service，然后将Host的地址传入即可。这些方法在内部会为我们将代码转化为传统的使用HttpWebRequest的方式请求，目前这些方法还都是同步的。&lt;/p&gt;
&lt;p&gt;比如，如果我们想使用WCF中使用的Soap11来请求，只需如下代码：&lt;/p&gt;
&lt;pre class="code"&gt;&lt;span style="color: blue;"&gt;static void &lt;/span&gt;&lt;span style="color: black;"&gt;Main(&lt;/span&gt;&lt;span style="color: blue;"&gt;string&lt;/span&gt;&lt;span style="color: black;"&gt;[] args)
{
    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Console&lt;/span&gt;&lt;span style="color: black;"&gt;.Title = &lt;/span&gt;&lt;span style="color: #a31515;"&gt;"ServiceStack Console Client"&lt;/span&gt;&lt;span style="color: black;"&gt;;

    &lt;/span&gt;&lt;span style="color: blue;"&gt;using &lt;/span&gt;&lt;span style="color: black;"&gt;(&lt;/span&gt;&lt;span style="color: blue;"&gt;var &lt;/span&gt;&lt;span style="color: black;"&gt;client = &lt;/span&gt;&lt;span style="color: blue;"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Soap11ServiceClient&lt;/span&gt;&lt;span style="color: black;"&gt;(&lt;/span&gt;&lt;span style="color: #a31515;"&gt;"http://localhost:1337"&lt;/span&gt;&lt;span style="color: black;"&gt;))
    {
        &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;List&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;gt; queuedTickets = client.Send&amp;lt;&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;List&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;lt;&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket&lt;/span&gt;&lt;span style="color: black;"&gt;&amp;gt;&amp;gt;(
            &lt;/span&gt;&lt;span style="color: blue;"&gt;new &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;GetAllTicketsInQueueRequest&lt;/span&gt;&lt;span style="color: black;"&gt;()) ;
        &lt;/span&gt;&lt;span style="color: blue;"&gt;if &lt;/span&gt;&lt;span style="color: black;"&gt;(queuedTickets != &lt;/span&gt;&lt;span style="color: blue;"&gt;null&lt;/span&gt;&lt;span style="color: black;"&gt;)
        {
            &lt;/span&gt;&lt;span style="color: blue;"&gt;foreach &lt;/span&gt;&lt;span style="color: black;"&gt;(&lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Ticket &lt;/span&gt;&lt;span style="color: black;"&gt;ticket &lt;/span&gt;&lt;span style="color: blue;"&gt;in &lt;/span&gt;&lt;span style="color: black;"&gt;queuedTickets)
            {
                PrintTicket(ticket);
            }
        }
    }
            
    &lt;/span&gt;&lt;span style="color: #2b91af;"&gt;Console&lt;/span&gt;&lt;span style="color: black;"&gt;.ReadKey();
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;这里的Soap11ServiceClient 对象可以换成ServiceStack支持的其他数据序列化格式。&lt;/p&gt;
&lt;h1&gt;&lt;span style="font-size: x-large;"&gt;四 结语&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;本文介绍了开源的比较流行的WebService框架ServiceStack，并通过一个简单的例子展现了如何使用ServiceStack创建出一个WebService。&lt;/p&gt;
&lt;p&gt;它能够比较方便快捷的搭建高效的具有RESTFull风格的WebService应用程序。其框架的设计思路也非常值得学习，通过类似&amp;ldquo;约定大于配置&amp;rdquo;的方式，减少了WCF中创建WebService需要的各种标记，强制用户使用DTO的方式来建立服务接口。ServiceStack也提供了名为ServiceStackVS的VisualStudio插件能够帮助您方便的创建ServiceStack模板。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/94031/201409/090122291372853.png"&gt;&lt;img style="display: inline; border-width: 0px;" title="ServiceStack Template" src="http://images.cnitblog.com/blog/94031/201409/090122321528565.png" alt="ServiceStack Template" width="945" height="650" border="0"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WCF可以实现ServiceStack所有的功能。但是ServiceStack为您快速创建一个高效WebService提供了另外一种选择，他可以运行于不同的平台。ServiceStack也是开源社区比较活跃的一个WebService框架，通过研究其代码也可以借鉴其思路，提高自己的编码和架构水平。比如可以修改Client以支持异步方法调用等等，可以自己动手添加自己想要的功能。&lt;/p&gt;
&lt;p&gt;希望本文对您了解ServiceStack有所帮助。&lt;/p&gt;&lt;/div&gt;&lt;div id="MySignature"&gt;&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="blog_post_info_block"&gt;
&lt;div id="BlogPostCategory"&gt;&lt;/div&gt;
&lt;div id="EntryTag"&gt;&lt;/div&gt;
&lt;div id="blog_post_info"&gt;
&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="post_next_prev"&gt;&lt;/div&gt;
&lt;/div&gt;


		&lt;/div&gt;
		&lt;div class="postDesc"&gt;posted @ &lt;span id="post-date"&gt;2014-09-09 01:23&lt;/span&gt; &lt;a href='http://www.cnblogs.com/yangecnu/'&gt;yangecnu&lt;/a&gt; 阅读(&lt;span id="post_view_count"&gt;...&lt;/span&gt;) 评论(&lt;span id="post_comment_count"&gt;...&lt;/span&gt;)  &lt;a href="http://i.cnblogs.com/EditPosts.aspx?postid=3961975" rel="nofollow"&gt;编辑&lt;/a&gt; &lt;a href="#" onclick="AddToWz(3961975);return false;"&gt;收藏&lt;/a&gt;&lt;/div&gt;
	&lt;/div&gt;
	&lt;script type="text/javascript"&gt;var allowComments=true,isLogined=false,cb_blogId=62045,cb_entryId=3961975,cb_blogApp=currentBlogApp,cb_blogUserGuid='53bba81b-63bc-de11-ba8f-001cf0cd104b',cb_entryCreatedDate='2014/9/9 1:23:00';loadViewCount(cb_entryId);&lt;/script&gt;
	
&lt;/div&gt;&lt;!--end: topics 文章、评论容器--&gt;
&lt;a name="!comments"&gt;&lt;/a&gt;&lt;div id="blog-comments-placeholder"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var commentManager = new blogCommentManager();commentManager.renderComments(0);&lt;/script&gt;
&lt;div id="comment_form" class="commentform"&gt;
&lt;a name="commentform"&gt;&lt;/a&gt;
&lt;div id="divCommentShow"&gt;&lt;/div&gt;
&lt;div id="comment_nav"&gt;&lt;span id="span_refresh_tips"&gt;&lt;/span&gt;&lt;a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();"&gt;刷新评论&lt;/a&gt;&lt;a href="#" onclick="return RefreshPage();"&gt;刷新页面&lt;/a&gt;&lt;a href="#top"&gt;返回顶部&lt;/a&gt;&lt;/div&gt;
&lt;div id="comment_form_container"&gt;&lt;/div&gt;
&lt;div class="ad_text_commentbox" id="ad_text_under_commentbox"&gt;&lt;/div&gt;
&lt;div id="site_nav_under"&gt;&lt;a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园"&gt;博客园首页&lt;/a&gt;&lt;a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区"&gt;博问&lt;/a&gt;&lt;a href="http://news.cnblogs.com/" target="_blank" title="IT新闻"&gt;新闻&lt;/a&gt;&lt;a href="http://home.cnblogs.com/ing/" target="_blank"&gt;闪存&lt;/a&gt;&lt;a href="http://job.cnblogs.com/" target="_blank"&gt;程序员招聘&lt;/a&gt;&lt;a href="http://kb.cnblogs.com/" target="_blank"&gt;知识库&lt;/a&gt;&lt;/div&gt;
&lt;div id="opt_under_post"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    var enableGoogleAd = canShowAdsense(); var googletag = googletag || {}; googletag.cmd = googletag.cmd || [];
    fixPostBodyFormat();
&lt;/script&gt;
&lt;div id="ad_under_post_holder"&gt;
&lt;script type='text/javascript'&gt;
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
    })();
&lt;/script&gt;
&lt;script type='text/javascript'&gt;
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function () {
                googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1346480159711-0').addService(googletag.pubads());
                googletag.pubads().enableSingleRequest();
                googletag.enableServices();
            });
        };
    } catch (e) { }
&lt;/script&gt;
&lt;div id="google_ad_c1" class="c_ad_block"&gt;
    &lt;div id='div-gpt-ad-1346480159711-0' style='width:300px; height:250px;'&gt;
    &lt;script type='text/javascript'&gt;
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1346480159711-0'); });            
            } else {
                $('#div-gpt-ad-1346480159711-0').hide();
            }
    } catch (e) { }
    &lt;/script&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="blog_news_kb"&gt;&lt;/div&gt;
&lt;div id="HistoryToday" class="c_ad_block"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
&lt;/script&gt;
&lt;/div&gt;

	&lt;/div&gt;&lt;!--end: forFlow --&gt;
	&lt;/div&gt;&lt;!--end: mainContent 主体内容容器--&gt;

	&lt;div id="sideBar"&gt;
		&lt;div id="sideBarMain"&gt;
			
&lt;!--done--&gt;
&lt;div class="newsItem"&gt;
&lt;h3 class="catListTitle"&gt;公告&lt;/h3&gt;
	&lt;div id="blog-news"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogNews();&lt;/script&gt;
&lt;/div&gt;

			&lt;div id="calendar"&gt;&lt;div id="blog-calendar" style="display:none"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogDefaultCalendar();&lt;/script&gt;&lt;/div&gt;
			
			&lt;div id="leftcontentcontainer"&gt;
				&lt;div id="blog-sidecolumn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogSideColumn();&lt;/script&gt;
			&lt;/div&gt;
			
		&lt;/div&gt;&lt;!--end: sideBarMain --&gt;
	&lt;/div&gt;&lt;!--end: sideBar 侧边栏容器 --&gt;
	&lt;div class="clear"&gt;&lt;/div&gt;
	&lt;/div&gt;&lt;!--end: main --&gt;
	&lt;div class="clear"&gt;&lt;/div&gt;
	&lt;div id="footer"&gt;
		
&lt;!--done--&gt;
Copyright &amp;copy;2014 yangecnu
	&lt;/div&gt;&lt;!--end: footer --&gt;
&lt;/div&gt;&lt;!--end: home 自定义的最大容器 --&gt;
&lt;!--PageEndHtml Block Begin--&gt;
&lt;script type="text/javascript"&gt;
    $(document).ready(function () {
        $("body").prepend($("#div_digg").css({
            "position": "fixed", "right": "0px", "bottom": "0px", "z-index": "10", "background-color": "white", "margin": "10px", "padding": "10px", "border": "1px solid #cccccc"
        }));
      $(".cnblogs_code_toolbar").hide();
    });
&lt;/script&gt;
&lt;!--PageEndHtml Block End--&gt;
&lt;/body&gt;
&lt;/html&gt;
</Html>
	<HtmlMetas i:nil="true" />
	<HtmlTitle i:nil="true" />
	<IsDefault>false</IsDefault>
	<Layout i:nil="true" />
	<Name>-yangecnu-p-3961975.html</Name>
	<OutputCache i:nil="true" />
	<PageContents xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
	<Plugins xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<Published>false</Published>
	<RequireHttps>false</RequireHttps>
	<Routes>
		<PageRoute>
			<Defaults xmlns:d4p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
			<Identifier>/yangecnu/p/3961975.html</Identifier>
			<RoutePath i:nil="true" />
		</PageRoute>
	</Routes>
	<Scripts i:nil="true" />
	<Site>
		<AbsoluteName xmlns="Ovaldi.Core.Models">Cnblogs</AbsoluteName>
	</Site>
	<Styles i:nil="true" />
	<UUID>-yangecnu-p-3961975.html</UUID>
</Page>