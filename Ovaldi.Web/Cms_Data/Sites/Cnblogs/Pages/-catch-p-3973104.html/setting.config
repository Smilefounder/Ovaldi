<?xml version="1.0" encoding="utf-8"?>
<Page xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/Ovaldi.Core.Models">
	<AbsoluteName>-catch-p-3973104.html</AbsoluteName>
	<CustomFields xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<EnableScript>true</EnableScript>
	<EnableTheming>true</EnableTheming>
	<Html>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;title&gt;Haskell 与范畴论 - twoon - 博客园&lt;/title&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/bundles/blog-common.css"&gt;
&lt;link id="MainCss" type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/skins/sea/bundle-sea.css"&gt;
&lt;link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/catch/rss"&gt;
&lt;link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/catch/rsd.xml"&gt;
&lt;link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/catch/wlwmanifest.xml"&gt;
&lt;script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"&gt;&lt;/script&gt;  
&lt;script type="text/javascript"&gt;var currentBlogApp = 'catch', cb_enable_mathjax=false;&lt;/script&gt;
&lt;script src="/preview~Cnblogs/Scripts/bundles/blog-common.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a name="top"&gt;&lt;/a&gt;

&lt;!--done--&gt;
&lt;div id="header"&gt;
	
&lt;!--done--&gt;
&lt;div class="header"&gt;
	&lt;div class="headerText"&gt;
		&lt;a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/catch/"&gt;&lt;/a&gt;&lt;br&gt;
		
	&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;div id="mytopmenu"&gt;
	
		&lt;div id="mylinks"&gt;
&lt;!--done--&gt;
&lt;a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/"&gt;博客园&lt;/a&gt; &amp;nbsp;
&lt;a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/catch/"&gt;首页&lt;/a&gt; &amp;nbsp;
&lt;a href="http://q.cnblogs.com" class="menu"&gt;博问&lt;/a&gt; &amp;nbsp;
&lt;a href="http://home.cnblogs.com/ing/" class="menu"&gt;闪存&lt;/a&gt; &amp;nbsp;
&lt;a id="MyLinks1_NewPostLink" class="menu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1"&gt;新随笔&lt;/a&gt; &amp;nbsp;
&lt;a id="MyLinks1_ContactLink" class="menu" rel="nofollow" href="http://space.cnblogs.com/msg/send/twoon"&gt;联系&lt;/a&gt; &amp;nbsp;
&lt;a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/catch/rss"&gt;订阅&lt;/a&gt;&lt;a id="MyLinks1_XMLLink" href="http://www.cnblogs.com/catch/rss"&gt;&lt;img src="/preview~Cnblogs/Images/images/xml.gif" alt="订阅"&gt;&lt;/a&gt;&amp;nbsp;
&lt;a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/"&gt;管理&lt;/a&gt;
&lt;/div&gt;
		&lt;div id="mystats"&gt;
&lt;!--done--&gt;
随笔-44&amp;nbsp;
评论-70&amp;nbsp;
文章-0&amp;nbsp;
trackbacks-0
&lt;/div&gt;
	
&lt;/div&gt;
&lt;div id="centercontent"&gt;
	

&lt;div class="post"&gt;
	&lt;h1 class="postTitle"&gt;&lt;a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/catch/p/3973104.html"&gt;Haskell 与范畴论&lt;/a&gt;&lt;/h1&gt;
	&lt;div id="cnblogs_post_body" class="cnblogs-markdown"&gt;&lt;p&gt;Haskell 是一门逼格极高的语言，这个评价肯定不为过，就我自身的经历及观察而言，一般初学者如果没有相关函数式编程的经验，入门直接接触那些稀奇古怪的概念，简直要跪下。现在回想起来，隐隐觉得初学者所拥有的命令式语言相关的知识和经验反而成了负担，若能抛掉以往固有的观念转以全新的视角来看待这些怪东西，仿佛会更好接受些，真是莫名其妙。&lt;/p&gt;
&lt;p&gt;Bartosz Milewski 的博客上写了很多关于 C++ 模板 与 Haskell 关系的相关文章，读来真是受益良多，这位大哥很多年前就开始探讨 c++ 模板编程与 Haskell 之间的微妙联系，许多观点让人眼前一亮以至叹为观止，比如说从范畴论的角度来理解和解释什么是单子(monad)(我接下来准备写篇博客总结一下)。Bartosz 讲 Haskell 喜欢从数学的角度来阐述，视角非同一般，当然他不是第一位这样做的，事实上 Haskell 与数学本来就有着许多不得不说又说不清道不明的暧昧关系(住口！)。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;范畴论基本概念&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果你是第一次听说范畴论，看到这高大上的名字估计心里就会一咯噔，到底数学威力巨大，光是高等数学就让很多人噩梦连连。和搞编程的一样，数学家喜欢将问题不断加以抽象从而将本质问题抽取出来加以论证解决，范畴论就是这样一门以抽象的方法来处理数学概念的学科，主要用于研究一些数学结构之间的关系及联系。&lt;/p&gt;
&lt;p&gt;在范畴论里，一个范畴(category)指的是这样一个东西，它由三部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一系列的对象(object).&lt;br&gt;&lt;/li&gt;
&lt;li&gt;一系列的态射(morphism).&lt;br&gt;&lt;/li&gt;
&lt;li&gt;一个组合(composition)操作符，用点(.)表示，用于将态射进行组合。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个对象可以看成是一类东西，数学上的群，环，甚至简单的有理数，无理数等都可以归为一个对象，对应到编程语言里，可以理解为一个类型，比如说整型，布尔型，&lt;strong&gt;类型事实上可以看成是值的集合&lt;/strong&gt;，例如整型就是由 0，1，2...等组成的，因此范畴论里的对象简单理解就可以看成是值(value)的集合。&lt;/p&gt;
&lt;p&gt;一个态射指的是一种映射关系，简单理解，态射的作用就是把一个对象 A 里的值 va 映射为 另一个对象 B 里的值 vb，这和代数里的映射概念是很相近的，因此也有单射，满射等区分。&lt;/p&gt;
&lt;p&gt;组合操作符的作用是将两个态射进行组合，例如，假设存在态射 f: A -&amp;gt; B, g: B -&amp;gt; C， 则 g.f : A -&amp;gt; c.&lt;/p&gt;
&lt;p&gt;看！好像没有想象中的复杂！一个结构要想成为一个范畴, 除了必须包含上述三样东西，它还要满足以下三个限制:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;态射要满足结合律，即 f.(g.h) = (f.g).h。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;态射在这个结构必须是封闭的，也就是，如果存在态射 f, g，则必然存在 h = f.g。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对结构中的每一个对象 A, 必须存在一个单位态射 Ia: A -&amp;gt; A， 对单位态射，显然，对任意其它态射 f, f.I = f。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;讲完了！范畴论就这么点东西！-- 当然是不可能的，但暂时来说，知道这些就已经很足够了。&lt;/p&gt;
&lt;h2 id="haskell-"&gt;&lt;strong&gt;Haskell 中的范畴&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在 Haskell 中存在着这样一个唯一的范畴，名字称为 Hask, 这个 Hask 满足前面关于范畴的全部约定，因此是范畴论里一个纯正的“范畴&amp;quot;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对象就是 Haskell 里的所有类型，记得类型是一个集合。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;态射就是编程语言里的一般函数(function)，如: &lt;code&gt;func :: Int -&amp;gt; Bool&lt;/code&gt;，将对象 int 映射为 对象 bool。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;态射的组合就是函数的组合，在 Haskell 里，函数也是通过点号(.)进行组合的。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外三个约束条件很容易证明也是满足，因此整个 Haskell 从数学的角度上看它就是一个范畴，这个角度的理解是很深刻的，这样一来传统意义上诸如语法，类型，函数等语言特性其实都只是这个内在本质的外在表现而已。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;函子&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;前面对范畴的介绍反映了范畴内部各个对象之间的联系与相互作用，在范畴论里另外研究的重点是范畴与范畴之间的关系，就正如对象与对象之间有态射一样，范畴与范畴之间也存在某些映射，从而可以将一个范畴映射为另一个范畴，这种映射在范畴论中叫作函子(functor），具体来说，对于给定的两个范畴 A 和 B, 函子的作用有两个:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将范畴 A 中的对象映射到范畴 B 中的对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将范畴 A 中的态射映射到范畴 B 中的态射。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，函子反映了不同的范畴之间的内在联系，函子的定义是十分松散的，而不同范畴之间的关系有强有弱，一个随便定义的函子很多时候并不能太深刻反映范畴之间结构上的联系，因此数学上，对函子通常有几个限制，先假设 F 是范畴 A 与范畴 B 上一个函子，则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对范畴 A 上的单位态射Ia, F 必须将其映射为范畴 B 上的单位态射 Ib, F(Ia) = Ib.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函子对态射的组合必须满足分配徤，即，假设 f, g 是范畴 A 上的态射，则 F(f.h) = F(f).F(g)。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然这两个限制是很强的，如果两个范畴之间存在这样一个函子，则反映了他们之间在结构上有着很强的相似性，从看似风牛马不相及的东西里找出他们内在的相似性，数学家最爱干的事情了。&lt;/p&gt;
&lt;p&gt;和态射一样函子也可以是自映射的，即函子允许将范畴映射到其自身，这样做有什么好处呢？不同范畴之间的映射反映了范畴间的相似性，范畴到范畴自身的映射则显然是反映了范畴内部的自相似性 --- 到底认识自己也不是一件容易的事啊。。。&lt;a href="http://en.wikipedia.org/wiki/Self-similarity"&gt;自相似性&lt;/a&gt;是大自然里美妙的存在，想想六角形的雪花，想想分形... 在范畴论里，这种将范畴映射到自身的函子被称为自函子(endofunctor).&lt;/p&gt;
&lt;h2 id="haskell-"&gt;&lt;strong&gt;Haskell 中的函子&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;知道为什么要讲自函子了吗，Haskell 中只有一个范畴! 那么这个唯一的范畴 Hask 中，存不存在自函子呢？有的！终于讲到重点了，为什么 Haskell 有这么些奇怪的概念？ Haskell 的老鸟会告诉你，这些奇怪的东西都是宝贝，它们都是有本而来的。&lt;/p&gt;
&lt;p&gt;那么 Haskell 中的自函子是怎么体现出来的呢？ 根据前面的定义，一个函子其实就是一个映射，它把对象映射为对象，把态射映射为态射，我们知道在 Haskell 中对象就是一个类型，如整型，布尔型等，将一个类型映射为另一个类型，没错，就是 type constructor 在干的事情，c++ 的程序员可以用模板类来想象一下，如，&lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt; 就是将 &lt;code&gt;int&lt;/code&gt; 映射为 &lt;code&gt;vector&amp;lt;int&amp;gt;&lt;/code&gt;， 这是两种不同的类型了，实例化模板的过程实际就是把一个类型变成另一个类型的过程。&lt;/p&gt;
&lt;p&gt;注意不要把对象的映射与对象内部的态射混淆了，态射是将对象内部的值进行映射，而对象的映射(函子)是把对象这个整体映射为另一个对象，函子根本不关心一个对象内部会有什么值。&lt;/p&gt;
&lt;p&gt;显然我们可以看到，在 Haskell 中，类型到类型的映射事实上并不是普遍存在的，自函子反映的是范畴内部的结构关系，这些关系并不是因为函子的存在而存在，函子只是揭示了这些内在的关系。具体在 Haskell 中，类型间的关系并不是普遍存在的，比如说， Int -&amp;gt; Bool 就没有对应的映射关系，而存在映射关系的类型，它们都有一些共同的特点，映射双方可以看成是由简单的类型转变为复杂的类型。&lt;/p&gt;
&lt;p&gt;type constructor 就是自函子的一部分！&lt;/p&gt;
&lt;p&gt;好了，现在类型到类型的映射在 Haskell 中找到了，那态射到态射之间的映射呢？必竟这也是函子的必要组成部分。&lt;/p&gt;
&lt;p&gt;在 Haskell 中，态射就是一般的函数，把一个函数映射为另一个函数，听起来不就是高阶函数在干的事情嘛。具体来说，映射函数这件事发生在 Functor 这个 typeclass 里，连名字都一模一样，目的昭然若揭。Haskell 中 Functor 是一个 &lt;a href="http://en.wikipedia.org/wiki/Type_class"&gt;typeclass&lt;/a&gt;，它的定义如下：&lt;/p&gt;
&lt;pre class="haskell"&gt;&lt;code&gt;class Functor f where
  fmap:: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; fb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fmap 干嘛的？显然就是用于把态射 &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; 映射为态射 &lt;code&gt;(f a -&amp;gt; f b)&lt;/code&gt;的，它把范畴里的态射映射到另一个态射，且遵守了函子在映射态射时所需要遵守的两个原则。&lt;/p&gt;
&lt;p&gt;讲到这里，我们一步一步不知不觉就已经向着 monad 靠近了，好激动，先打住了，回头再整理整理。&lt;/p&gt;
&lt;p&gt;【参考】&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikibooks.org/wiki/Haskell/Category_theory"&gt;http://en.wikibooks.org/wiki/Haskell/Category_theory&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/"&gt;http://bartoszmilewski.com/2011/01/09/monads-for-the-curious-programmer-part-1/&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id="MySignature"&gt;&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="blog_post_info_block"&gt;
&lt;div id="BlogPostCategory"&gt;&lt;/div&gt;
&lt;div id="EntryTag"&gt;&lt;/div&gt;
&lt;div id="blog_post_info"&gt;
&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="post_next_prev"&gt;&lt;/div&gt;
&lt;/div&gt;


	&lt;div class="postDesc"&gt;posted on &lt;span id="post-date"&gt;2014-09-15 21:54&lt;/span&gt; &lt;a href='http://www.cnblogs.com/catch/'&gt;twoon&lt;/a&gt; 阅读(&lt;span id="post_view_count"&gt;...&lt;/span&gt;) 评论(&lt;span id="post_comment_count"&gt;...&lt;/span&gt;)  &lt;a href="http://i.cnblogs.com/EditPosts.aspx?postid=3973104" rel="nofollow"&gt;编辑&lt;/a&gt; &lt;a href="#" onclick="AddToWz(3973104);return false;"&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script src="http://cdn.cnblogs.com/highlight/highlight.min.js"&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt;&lt;script type="text/javascript"&gt;var allowComments=true,isLogined=false,cb_blogId=140806,cb_entryId=3973104,cb_blogApp=currentBlogApp,cb_blogUserGuid='27ba3157-e465-e211-aa8f-842b2b196315',cb_entryCreatedDate='2014/9/15 21:54:00';loadViewCount(cb_entryId);&lt;/script&gt;

&lt;a name="!comments"&gt;&lt;/a&gt;&lt;div id="blog-comments-placeholder"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var commentManager = new blogCommentManager();commentManager.renderComments(0);&lt;/script&gt;
&lt;div id="comment_form" class="commentform"&gt;
&lt;a name="commentform"&gt;&lt;/a&gt;
&lt;div id="divCommentShow"&gt;&lt;/div&gt;
&lt;div id="comment_nav"&gt;&lt;span id="span_refresh_tips"&gt;&lt;/span&gt;&lt;a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();"&gt;刷新评论&lt;/a&gt;&lt;a href="#" onclick="return RefreshPage();"&gt;刷新页面&lt;/a&gt;&lt;a href="#top"&gt;返回顶部&lt;/a&gt;&lt;/div&gt;
&lt;div id="comment_form_container"&gt;&lt;/div&gt;
&lt;div class="ad_text_commentbox" id="ad_text_under_commentbox"&gt;&lt;/div&gt;
&lt;div id="site_nav_under"&gt;&lt;a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园"&gt;博客园首页&lt;/a&gt;&lt;a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区"&gt;博问&lt;/a&gt;&lt;a href="http://news.cnblogs.com/" target="_blank" title="IT新闻"&gt;新闻&lt;/a&gt;&lt;a href="http://home.cnblogs.com/ing/" target="_blank"&gt;闪存&lt;/a&gt;&lt;a href="http://job.cnblogs.com/" target="_blank"&gt;程序员招聘&lt;/a&gt;&lt;a href="http://kb.cnblogs.com/" target="_blank"&gt;知识库&lt;/a&gt;&lt;/div&gt;
&lt;div id="opt_under_post"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    var enableGoogleAd = canShowAdsense(); var googletag = googletag || {}; googletag.cmd = googletag.cmd || [];
    fixPostBodyFormat();
&lt;/script&gt;
&lt;div id="ad_under_post_holder"&gt;
&lt;script type='text/javascript'&gt;
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
    })();
&lt;/script&gt;
&lt;script type='text/javascript'&gt;
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function () {
                googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1346480159711-0').addService(googletag.pubads());
                googletag.pubads().enableSingleRequest();
                googletag.enableServices();
            });
        };
    } catch (e) { }
&lt;/script&gt;
&lt;div id="google_ad_c1" class="c_ad_block"&gt;
    &lt;div id='div-gpt-ad-1346480159711-0' style='width:300px; height:250px;'&gt;
    &lt;script type='text/javascript'&gt;
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1346480159711-0'); });            
            } else {
                $('#div-gpt-ad-1346480159711-0').hide();
            }
    } catch (e) { }
    &lt;/script&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="blog_news_kb"&gt;&lt;/div&gt;
&lt;div id="HistoryToday" class="c_ad_block"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
&lt;/script&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div id="leftcontent"&gt;
	
		&lt;div id="leftcontentcontainer"&gt;
			
&lt;!--done--&gt;
&lt;div class="newsItem"&gt;
	&lt;div id="blog-news"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogNews();&lt;/script&gt;
&lt;/div&gt;

			&lt;div id="blog-calendar" style="display:none"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogDefaultCalendar();&lt;/script&gt;&lt;br&gt;
			&lt;div id="blog-sidecolumn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogSideColumn();&lt;/script&gt;&lt;/div&gt;
	
&lt;/div&gt;

&lt;!--done--&gt;
&lt;div class="footer"&gt;
	Powered by: &lt;a href="http://www.cnblogs.com"&gt;博客园&lt;/a&gt;	模板提供：&lt;a href="http://blog.hjenglish.com"&gt;沪江博客&lt;/a&gt;
	Copyright &amp;copy;2014 twoon
&lt;/div&gt;



&lt;/body&gt;
&lt;/html&gt;
</Html>
	<HtmlMetas i:nil="true" />
	<HtmlTitle i:nil="true" />
	<IsDefault>false</IsDefault>
	<Layout i:nil="true" />
	<Name>-catch-p-3973104.html</Name>
	<OutputCache i:nil="true" />
	<PageContents xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
	<Plugins xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<Published>false</Published>
	<RequireHttps>false</RequireHttps>
	<Routes>
		<PageRoute>
			<Defaults xmlns:d4p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
			<Identifier>/catch/p/3973104.html</Identifier>
			<RoutePath i:nil="true" />
		</PageRoute>
	</Routes>
	<Scripts i:nil="true" />
	<Site>
		<AbsoluteName xmlns="Ovaldi.Core.Models">Cnblogs</AbsoluteName>
	</Site>
	<Styles i:nil="true" />
	<UUID>-catch-p-3973104.html</UUID>
</Page>