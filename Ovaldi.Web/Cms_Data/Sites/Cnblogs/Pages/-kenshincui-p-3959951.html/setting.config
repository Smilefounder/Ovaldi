<?xml version="1.0" encoding="utf-8"?>
<Page xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/Ovaldi.Core.Models">
	<AbsoluteName>-kenshincui-p-3959951.html</AbsoluteName>
	<CustomFields xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<EnableScript>true</EnableScript>
	<EnableTheming>true</EnableTheming>
	<Html>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-cn"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;iOS开发系列--打造自己的&amp;ldquo;美图秀秀&amp;rdquo; - KenshinCui - 博客园&lt;/title&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/bundles/blog-common.css"&gt;
&lt;link id="MainCss" type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/skins/Minyx2_Lite/bundle-Minyx2_Lite.css"&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/blog/customcss/79371.css"&gt;
&lt;link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/kenshincui/rss"&gt;
&lt;link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/kenshincui/rsd.xml"&gt;
&lt;link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/kenshincui/wlwmanifest.xml"&gt;
&lt;script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"&gt;&lt;/script&gt;  
&lt;script type="text/javascript"&gt;var currentBlogApp = 'kenshincui', cb_enable_mathjax=false;&lt;/script&gt;
&lt;script src="/preview~Cnblogs/Scripts/bundles/blog-common.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;script src="/preview~Cnblogs/Scripts/skins/Minyx2_Lite/bundle-Minyx2_Lite.js" language="javascript" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a name="top"&gt;&lt;/a&gt;
&lt;!--PageBeginHtml Block Begin--&gt;
&lt;link href="http://files.cnblogs.com/kenshincui/CNBlogsNavigation-0.5.2.min.css" rel="stylesheet"&gt;
&lt;!--PageBeginHtml Block End--&gt;


&lt;div id="container"&gt;
    &lt;a class="minyx" href="http://www.cnblogs.com/"&gt;代码改变世界&lt;/a&gt;
    &lt;ul id="topMnu"&gt;
        &lt;!-- 统计数据 --&gt;
        &lt;li&gt;
            
                
Posts - 61, 
Articles - 0, 
Comments - 438
&lt;!----&gt;
            
        &lt;/li&gt;
        &lt;!-- 这边可以增加一些链接 --&gt;
        &lt;!-- 博客园 --&gt;
        &lt;li&gt;&lt;a href="http://www.cnblogs.com"&gt;Cnblogs&lt;/a&gt;&lt;/li&gt;
        &lt;!-- 管理 --&gt;
        &lt;li id="topMnu-dashboard"&gt;
            &lt;a id="lnkDashboard" href="http://www.cnblogs.com/kenshincui/admin/EditPosts.aspx"&gt;Dashboard&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;
            &lt;a id="lnkLogin" href="http://passport.cnblogs.com/login.aspx?ReturnUrl=http://www.cnblogs.com/kenshincui/p/3959951.html"&gt;Login&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;

    &lt;script type="text/javascript"&gt;
        var m = window.__blog.topMenuRendered;
        if (m) { m(__$("topMnu")); }
    &lt;/script&gt;

    &lt;div id="header"&gt;
        &lt;ul id="menu"&gt;
            &lt;!-- 首页，当前section加上current类 --&gt;
            &lt;li id="menu-home" class="current"&gt;
                &lt;a id="lnkHome" href="http://www.cnblogs.com/kenshincui/"&gt;Home&lt;/a&gt;&lt;/li&gt;
            &lt;!-- 联系 --&gt;
            &lt;li id="menu-contact"&gt;
                &lt;a id="lnkContact" href="http://space.cnblogs.com/msg/send/KenshinCui"&gt;Contact&lt;/a&gt;&lt;/li&gt;
            &lt;!-- 相册 --&gt;
            &lt;li id="menu-gallary"&gt;
                &lt;a id="lnkGallery" href="http://www.cnblogs.com/kenshincui/gallery.html"&gt;Gallery&lt;/a&gt;&lt;/li&gt;
            &lt;!-- Rss订阅 --&gt;
            &lt;li id="rss"&gt;
                &lt;a id="lnkRss" href="http://www.cnblogs.com/kenshincui/rss"&gt;RSS&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div id="newmsg"&gt;&lt;/div&gt;
        &lt;h1&gt;
            &lt;!-- 主标题 --&gt;
            &lt;a id="lnkBlogTitle" href="http://www.cnblogs.com/kenshincui/"&gt;Kenshin Cui's Blog&lt;/a&gt;
            &lt;!-- 子标题 --&gt;
            &lt;small&gt;
                CODING 完美世界...&lt;/small&gt;
        &lt;/h1&gt;
    &lt;/div&gt;

    &lt;script type="text/javascript"&gt;
        var m = window.__blog.headerRendered;
        if (m) { m(__$("header")); }
    &lt;/script&gt;

    &lt;div id="wrapper"&gt;
        &lt;div id="content"&gt;
            &lt;script type="text/javascript"&gt;
                var m = window.__blog.preRenderPosts;
                if (m) { m(); }
            &lt;/script&gt;
            

&lt;div class="post" id="post"&gt;
    &lt;a name="top"&gt;&lt;/a&gt;
    &lt;h2&gt;&lt;a id="cb_post_title_url" href="http://www.cnblogs.com/kenshincui/p/3959951.html"&gt;iOS开发系列--打造自己的&amp;ldquo;美图秀秀&amp;rdquo;&lt;/a&gt;&lt;/h2&gt;
    &lt;small&gt;2014-09-06 23:33 by KenshinCui, &lt;span id="post_view_count"&gt;...&lt;/span&gt; 阅读, &lt;span id="post_comment_count"&gt;...&lt;/span&gt; 评论, &lt;a href="#" onclick="AddToWz({0});return false;"&gt;收藏&lt;/a&gt;,  &lt;a href="http://i.cnblogs.com/EditPosts.aspx?postid=3959951" rel="nofollow"&gt;编辑&lt;/a&gt;&lt;/small&gt;
    &lt;div class="entry"&gt;
        &lt;div id="cnblogs_post_body"&gt;&lt;p align="right"&gt;&lt;strong&gt;--绘图与滤镜全面解析&lt;/strong&gt;&lt;/p&gt; &lt;h1 id="overview"&gt;概述&lt;/h1&gt; &lt;p&gt;在iOS中可以很容易的开发出绚丽的界面效果，一方面得益于成功系统的设计，另一方面得益于它强大的开发框架。今天我们将围绕iOS中两大图形、图像绘图框架进行介绍：Quartz 2D绘制2D图形和Core Image中强大的滤镜功能。&lt;/p&gt; &lt;ol&gt; &lt;li&gt;&lt;a href="#quartz2d"&gt;Quartz 2D&lt;/a&gt;  &lt;li&gt;&lt;a href="#basicDraw"&gt;基本图形绘制&lt;/a&gt;  &lt;li&gt;&lt;a href="#refreshView"&gt;视图刷新&lt;/a&gt;  &lt;li&gt;&lt;a href="#otherCGContext"&gt;其他图形上下文&lt;/a&gt;  &lt;li&gt;&lt;a href="#coreImage"&gt;Core Image&lt;/a&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ol&gt; &lt;h1 id="quartz2d"&gt;Quartz 2D&lt;/h1&gt; &lt;p&gt;在iOS中常用的绘图框架就是Quartz 2D，Quartz 2D是Core Graphics框架的一部分，是一个强大的二维图像绘制引擎。Quartz 2D在UIKit中也有很好的封装和集成，我们日常开发时所用到的UIKit中的组件都是由Core Graphics进行绘制的。不仅如此，当我们引入UIKit框架时系统会自动引入Core Graphics框架，并且为了方便开发者使用在UIKit内部还对一些常用的绘图API进行了封装。&lt;/p&gt; &lt;p&gt;在iOS中绘图一般分为以下几个步骤：&lt;/p&gt; &lt;p&gt;1.获取绘图上下文&lt;/p&gt; &lt;p&gt;2.创建并设置路径&lt;/p&gt; &lt;p&gt;3.将路径添加到上下文&lt;/p&gt; &lt;p&gt;4.设置上下文状态&lt;/p&gt; &lt;p&gt;5.绘制路径&lt;/p&gt; &lt;p&gt;6.释放路径&lt;/p&gt; &lt;p&gt;图形上下文CGContextRef代表图形输出设备（也就是绘制的位置），包含了绘制图形的一些设备信息，Quartz 2D中的所有对象最终都必须绘制到图形上下文。这样一来，我们在绘制图形时就不必关心具体的设备信息，统一了代码编写方式（在Quartz 2D中的绘图上下文可以是位图Bitmap、PDF、窗口Window、层Layer、打印对象Printer）。&lt;/p&gt; &lt;h1 id="basicDraw"&gt;基本图形绘制&lt;/h1&gt; &lt;p&gt;在UIKit中默认已经为我们准备好了一个图形上下文对象，在UI控件的&lt;strong&gt;drawRect:&lt;/strong&gt;方法（这个方法在loadView、viewDidLoad方法后执行）中我们可以通过UIKit封装函数UIGraphicsGetCurrentContext()方法获得这个图形上下文(注意在其他UI控件方法中无法取得这个对象)，然后我们只要按照绘图步骤一步步执行即可。下面自定义一个KCView继承自UIView，重写drawRect:方法绘制两条直线说明上面绘图的步骤：&lt;/p&gt; &lt;p&gt;KCView.m&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCView.m
//  Quartz2D
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
/**
 基本绘图
 */

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView.h"

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@implementation KCView

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 绘图
&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘图只能在此方法中调用，否则无法得到当前图形上下文
&lt;/span&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRect:(CGRect)rect{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//1.取得图形上下文对象
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextRef context = UIGraphicsGetCurrentContext();

    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//2.创建路径对象
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGMutablePathRef path = CGPathCreateMutable();
    CGPathMoveToPoint(path, nil, 20, 50);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//移动到指定位置（设置路径起点）
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGPathAddLineToPoint(path, nil, 20, 100);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制直线（从起始位置开始）
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGPathAddLineToPoint(path, nil, 300, 100);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制另外一条直线（从上一直线终点开始绘制）


    //3.添加路径到图形上下文
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextAddPath(context, path);

    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//4.设置图形上下文状态属性
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetRGBStrokeColor(context, 1.0, 0, 0, 1);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置笔触颜色
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetRGBFillColor(context, 0, 1.0, 0, 1);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置填充色
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetLineWidth(context, 2.0);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置线条宽度
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetLineCap(context, kCGLineCapRound);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置顶点样式,（20,50）和（300,100）是顶点
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetLineJoin(context, kCGLineJoinRound);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置连接点样式，(20,100)是连接点
    /*设置线段样式
    phase:虚线开始的位置
    lengths:虚线长度间隔（例如下面的定义说明第一条线段长度8，然后间隔3重新绘制8点的长度线段，当然这个数组可以定义更多元素）
    count:虚线数组元素个数
    */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGFloat lengths[2] = { 18, 9 };
    CGContextSetLineDash(context, 0, lengths, 2);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*设置阴影
    context:图形上下文
    offset:偏移量
    blur:模糊度
    color:阴影颜色
    */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorRef color = [UIColor grayColor].CGColor;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//颜色转化，由于Quartz 2D跨平台，所以其中不能使用UIKit中的对象，但是UIkit提供了转化方法
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetShadowWithColor(context, CGSizeMake(2, 2), 0.8, color);

    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//5.绘制图像到指定图形上下文
    /*CGPathDrawingMode是填充方式,枚举类型
    kCGPathFill:只有填充（非零缠绕数填充），不绘制边框
    kCGPathEOFill:奇偶规则填充（多条路径交叉时，奇数交叉填充，偶交叉不填充）
    kCGPathStroke:只有边框
    kCGPathFillStroke：既有边框又有填充
    kCGPathEOFillStroke：奇偶填充并绘制边框
    */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawPath(context, kCGPathFillStroke);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//最后一个参数是填充类型

    //6.释放对象
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGPathRelease(path);
}&lt;/span&gt;&lt;span style="background: white; color: black"&gt;
@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;在视图控制器创建KCView并添加到根视图中：&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;- (&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)viewDidLoad {
    [super viewDidLoad];
    
    KCView *view=[[KCView alloc]initWithFrame:[UIScreen mainScreen].bounds];
    view.backgroundColor=[UIColor whiteColor];
    [self.view addSubview:view];
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062331581107913.jpg"&gt;&lt;img title="DrawPath" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawPath" src="http://images.cnitblog.com/blog/62046/201409/062331584698571.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;简化绘图方式&lt;/h2&gt;
&lt;p&gt;上面的绘图方式未免显得有些麻烦，其实Core Graphics 内部对创建对象添加到上下文这两步操作进行了封装，可以一步完成。另外前面也说过UIKit内部其实封装了一些以“UI”开头的方法帮助大家进行图形绘制。就拿前面的例子来说我们改进一些绘制方法：&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawLine2{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//1.获得图形上下文
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextRef context=UIGraphicsGetCurrentContext();
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//2.绘制路径（相当于前面创建路径并添加路径到图形上下文两步操作）
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextMoveToPoint(context, 20, 50);
    CGContextAddLineToPoint(context, 20, 100);
    CGContextAddLineToPoint(context, 300, 100);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//封闭路径:a.创建一条起点和终点的线,不推荐
    //CGPathAddLineToPoint(path, nil, 20, 50);
    //封闭路径:b.直接调用路径封闭方法
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextClosePath(context);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//3.设置图形上下文属性
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor redColor]setStroke];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置红色边框
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor greenColor]setFill];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置绿色填充
    //[[UIColor blueColor]set];//同时设置填充和边框色
    
    //4.绘制路径
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawPath(context, kCGPathFillStroke);
}&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;上面的操作相比前面的方法应该说已经简化了不少，除了路径之外其他矩形、椭圆等都有对应的创建方法。另外上面我们也演示了封闭路径的方法，大家可以运行看一下效果。&lt;/p&gt;
&lt;h2&gt;其他图形绘制&lt;/h2&gt;
&lt;p&gt;相信大家了解了上面的绘制步骤其他图形绘制并不麻烦，下面以一个例子简单演示一下其他图形的绘制，包括文字和图像的绘制。&lt;/p&gt;
&lt;h3&gt;绘制矩形&lt;/h3&gt;
&lt;p&gt;在下面的方法中还可以看到UIKit对绘图方法的封装，使用起来更加简单。&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 绘制矩形
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRectWithContext:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//添加矩形对象
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGRect rect=CGRectMake(20, 50, 280.0, 50.0);
    CGContextAddRect(context,rect);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置属性
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor blueColor]set];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawPath(context, kCGPathFillStroke);
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 绘制矩形（利用UIKit的封装方法）
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRectByUIKitWithContext:(CGContextRef)context{
    CGRect rect= CGRectMake(20, 150, 280.0, 50.0);
    CGRect rect2=CGRectMake(20, 250, 280.0, 50.0);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置属性
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor yellowColor]set];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制矩形,相当于创建对象、添加对象到上下文、绘制三个步骤
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIRectFill(rect);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制矩形（只有填充）
    
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor redColor]setStroke];
    UIRectFrame(rect2);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制矩形(只有边框)
&lt;/span&gt;&lt;span style="background: white; color: black"&gt;}
@end&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062331591102742.jpg"&gt;&lt;img title="DrawRect" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawRect" src="http://images.cnitblog.com/blog/62046/201409/062331593608198.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;绘制椭圆&lt;/h3&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 绘制椭圆
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawEllipse:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//添加对象,绘制椭圆（圆形）的过程也是先创建一个矩形
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGRect rect=CGRectMake(50, 50, 220.0, 200.0);
    CGContextAddEllipseInRect(context, rect);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置属性
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor purpleColor]set];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawPath(context, kCGPathFillStroke);
}
@end&lt;/span&gt;&amp;nbsp;&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062331597976599.jpg"&gt;&lt;img title="DrawEllipse" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawEllipse" src="http://images.cnitblog.com/blog/62046/201409/062332000948041.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;绘制弧形&lt;/h3&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawArc:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*添加弧形对象
     x:中心点x坐标
     y:中心点y坐标
     radius:半径
     startAngle:起始弧度
     endAngle:终止弧度
     closewise:是否逆时针绘制，0则顺时针绘制
    */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextAddArc(context, 160, 160, 100.0, 0.0, M_PI_2, 1);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置属性
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor yellowColor]set];
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawPath(context, kCGPathFillStroke);
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332003132742.jpg"&gt;&lt;img title="DrawArc" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawArc" src="http://images.cnitblog.com/blog/62046/201409/062332008134656.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;绘制贝塞尔曲线&lt;/h3&gt;
&lt;p&gt;要绘制规则图形在iOS中相当简单，但是不规则图形怎么绘制呢？此时就要利用路径。前面我们绘制了直线，它和曲线绘制都属于路径绘制。和直线绘制相比曲线绘制就要复杂一些，但是路径作为高级动画的基础又是我们必须掌握的，因此这里我们就一起来熟悉一下曲线绘制。在Quartz 2D中曲线绘制分为两种：二次贝塞尔曲线和三次贝塞尔曲线。二次曲线只有一个控制点，而三次曲线有两个控制点，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332011254626.png"&gt;&lt;img title="Bezier" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="Bezier" src="http://images.cnitblog.com/blog/62046/201409/062332014389298.png" width="730" height="350"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然，在iOS中两种曲线分别对应两种方法： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CGContextAddQuadCurveToPoint(CGContextRef c, CGFloat cpx, CGFloat cpy, CGFloat x, CGFloat y);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CGContextAddCurveToPoint(context, CGFloat cp1x, CGFloat cp1y, CGFloat cp2x, CGFloat cp2y, CGFloat x, CGFloat y);&lt;/strong&gt;&lt;br&gt;下面就演示一下这两种曲线的绘制方法&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 绘制贝塞尔曲线
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawCurve:(CGContextRef)context{
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制曲线
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextMoveToPoint(context, 20, 100);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//移动到起始位置
    /*绘制二次贝塞尔曲线
     c:图形上下文
     cpx:控制点x坐标
     cpy:控制点y坐标
     x:结束点x坐标
     y:结束点y坐标
    */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextAddQuadCurveToPoint(context, 160, 0, 300, 100);
    
    CGContextMoveToPoint(context, 20, 500);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*绘制三次贝塞尔曲线
     c:图形上下文
     cp1x:第一个控制点x坐标
     cp1y:第一个控制点y坐标
     cp2x:第二个控制点x坐标
     cp2y:第二个控制点y坐标
     x:结束点x坐标
     y:结束点y坐标
    */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextAddCurveToPoint(context, 80, 300, 240, 500, 300, 300);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置图形上下文属性
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[[UIColor yellowColor]setFill];
    [[UIColor redColor]setStroke];
    
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制路径
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawPath(context, kCGPathFillStroke);
    
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332022502183.jpg"&gt;&lt;img title="BesizerEffice" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="BesizerEffice" src="http://images.cnitblog.com/blog/62046/201409/062332025161869.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;备注:贝塞尔曲线是由法国数学家“贝塞尔”发现的，他发现：任何一条曲线都能够由和它相切的直线的两个端点来描述，这种曲线表示方式后来被广泛应用到计算机中，称为“贝塞尔曲线”。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3&gt;文字绘制&lt;/h3&gt;
&lt;p&gt;除了绘制图形还可以绘制文本内容。&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawText:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制到指定的区域内容
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;NSString *str=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Star Walk is the most beautiful stargazing app you’ve ever seen on a mobile device. It will become your go-to interactive astro guide to the night sky, following your every movement in real-time and allowing you to explore over 200, 000 celestial bodies with extensive information about stars and constellations that you find."&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    CGRect rect= CGRectMake(20, 50, 280, 300);
    UIFont *font=[UIFont systemFontOfSize:18];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置字体
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIColor *color=[UIColor redColor];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//字体颜色
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;NSMutableParagraphStyle *style=[[NSMutableParagraphStyle alloc]init];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//段落样式
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;NSTextAlignment align=NSTextAlignmentLeft;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//对齐方式
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;style.alignment=align;
    [str drawInRect:rect withAttributes:@{NSFontAttributeName:font,NSForegroundColorAttributeName:color,NSParagraphStyleAttributeName:style}];
}&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332037196167.jpg"&gt;&lt;img title="DrawText" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawText" src="http://images.cnitblog.com/blog/62046/201409/062332040945353.jpg" width="320" height="590"&gt;&lt;/a&gt;&amp;nbsp;&lt;/p&gt;
&lt;h3&gt;图像绘制&lt;/h3&gt;
&lt;p&gt;Quartz 2D还可以将图像绘制到图形上下文。&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawImage:(CGContextRef)context{
    UIImage *image=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"image2.jpg"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//从某一点开始绘制
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[image drawAtPoint:CGPointMake(10, 50)];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//绘制到指定的矩形中，注意如果大小不合适会会进行拉伸
//    [image drawInRect:CGRectMake(10, 50, 300, 450)];
    //平铺绘制
//    [image drawAsPatternInRect:CGRectMake(0, 0, 320, 568)];
&lt;/span&gt;&lt;span style="background: white; color: black"&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332046725009.jpg"&gt;&lt;img title="DrawImage" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawImage" src="http://images.cnitblog.com/blog/62046/201409/062332051881153.jpg" width="320" height="590"&gt;&lt;/a&gt;&amp;nbsp;&lt;/p&gt;
&lt;h2&gt;绘制渐变填充&lt;/h2&gt;
&lt;p&gt;从前面的示例中我们可以看到如何设置填充颜色，事实上很多时候纯色的填充并不能满足我们的需求，例如有时候我们要绘制一些图形可能需要设置一个漂亮的背景，这个时候我们可能就会选择渐变填充方式。Quartz 2D的渐变方式分为两种：&lt;/p&gt;
&lt;p&gt;a.线性渐变线：渐变色以直线方式从开始位置逐渐向结束位置渐变&lt;/p&gt;
&lt;p&gt;b.径向渐变：以中心点为圆心从起始渐变色向四周辐射，直到终止渐变色&lt;/p&gt;
&lt;p&gt;要做渐变则必须先设置从开始位置到结束位置的渐变颜色，做过photoshop的朋友相信对于渐变色设置并不陌生，只要在指定位置指定不同的颜色，剩下的事情交给系统处理即可，如下图在起始位置、3/10位置、结束位置指定了三种颜色就形成由三种颜色组成的渐变色：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332055787865.png"&gt;&lt;img title="GradientColor" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="GradientColor" src="http://images.cnitblog.com/blog/62046/201409/062332057972566.png" width="425" height="55"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;另外，在iOS中绘制渐变还需要注意一点就是指定颜色空间，所谓颜色空间就是不同颜色在不同的维度上取值最终组成一种颜色的过程。就拿RGB来说，如果将红色、绿色、蓝色看成是x、y、z轴坐标系，那么在三个坐标上分别取0~255范围内的不同值则可以组成各类颜色。当然，不同颜色空间的“坐标系”也是不同的（也就是说颜色表示的方式是不同的），常用的颜色空间除了RGB还有CMYK（印刷业常用这种颜色模式）、Gray。&lt;/p&gt;
&lt;p&gt;在使用Quartz 2D绘图时我们的颜色除了使用常规的方法（如何前面&lt;strong&gt;CGContextSetRGBFillColor(CGContextRef context, CGFloat red, CGFloat green, CGFloat blue, CGFloat alpha)&lt;/strong&gt;方法）设置RGB和透明度外，有时还会遇到颜色参数是一个数组情况。如使用颜色空间填充时用到的&lt;strong&gt;CGContextSetFillColor(CGContextRef context, const CGFloat *components)&lt;/strong&gt;方法，这个时候components数组中具体是如何存储颜色就要根据颜色空间而定，如果颜色空间使用RGB则数组中的元素四个为一组，分别是red（红）、green（绿）、blue（蓝）、alpha（透明度）；如果使用CMYK颜色空间，那么数组中的元素五个为一组，分别是cyan（青）、magenta（洋红）、yellow（黄）、black（黑）、alpha（透明度）。&lt;/p&gt;
&lt;p&gt;下面的代码分别演示了两种渐变方式，具体渐变绘制函数参数代码中已经注释的很清楚了：&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCView3.m
//  Quartz2D
//
//  Created by Kenshin Cui on 14-3-16.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView3.h"

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@implementation KCView3

-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRect:(CGRect)rect{
    CGContextRef context=UIGraphicsGetCurrentContext();
&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//    [self drawLinearGradient:context];
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[self drawRadialGradient:context];
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 线性渐变
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawLinearGradient:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//使用rgb颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB();
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*指定渐变色
     space:颜色空间
     components:颜色数组,注意由于指定了RGB颜色空间，那么四个数组元素表示一个颜色（red、green、blue、alpha），
                如果有三个颜色则这个数组有4*3个元素
     locations:颜色所在位置（范围0~1），这个数组的个数不小于components中存放颜色的个数
     count:渐变个数，等于locations的个数
     */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGFloat compoents[12]={
        248.0/255.0,86.0/255.0,86.0/255.0,1,
        249.0/255.0,127.0/255.0,127.0/255.0,1,
        1.0,1.0,1.0,1.0
    };
    CGFloat locations[3]={0,0.3,1.0};
    CGGradientRef gradient= CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 3);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*绘制线性渐变
     context:图形上下文
     gradient:渐变色
     startPoint:起始位置
     endPoint:终止位置
     options:绘制方式,kCGGradientDrawsBeforeStartLocation 开始位置之前就进行绘制，到结束位置之后不再绘制，
             kCGGradientDrawsAfterEndLocation开始位置之前不进行绘制，到结束点之后继续填充
     */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawLinearGradient(context, gradient, CGPointZero, CGPointMake(320, 300), kCGGradientDrawsAfterEndLocation);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//释放颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRelease(colorSpace);
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 径向渐变
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRadialGradient:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//使用rgb颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB();
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*指定渐变色
     space:颜色空间
     components:颜色数组,注意由于指定了RGB颜色空间，那么四个数组元素表示一个颜色（red、green、blue、alpha），
     如果有三个颜色则这个数组有4*3个元素
     locations:颜色所在位置（范围0~1），这个数组的个数不小于components中存放颜色的个数
     count:渐变个数，等于locations的个数
     */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGFloat compoents[12]={
        248.0/255.0,86.0/255.0,86.0/255.0,1,
        249.0/255.0,127.0/255.0,127.0/255.0,1,
        1.0,1.0,1.0,1.0
    };
    CGFloat locations[3]={0,0.3,1.0};
    CGGradientRef gradient= CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 3);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*绘制径向渐变
     context:图形上下文
     gradient:渐变色
     startCenter:起始点位置
     startRadius:起始半径（通常为0，否则在此半径范围内容无任何填充）
     endCenter:终点位置（通常和起始点相同，否则会有偏移）
     endRadius:终点半径（也就是渐变的扩散长度）
     options:绘制方式,kCGGradientDrawsBeforeStartLocation 开始位置之前就进行绘制，但是到结束位置之后不再绘制，
             kCGGradientDrawsAfterEndLocation开始位置之前不进行绘制，但到结束点之后继续填充
     */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextDrawRadialGradient(context, gradient, CGPointMake(160, 284),0, CGPointMake(165, 289), 150, kCGGradientDrawsAfterEndLocation);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//释放颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRelease(colorSpace);
}
@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332060632252.jpg"&gt;&lt;img title="LinearGradient" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="LinearGradient" src="http://images.cnitblog.com/blog/62046/201409/062332063449465.jpg" width="260" height="480"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;a href="http://images.cnitblog.com/blog/62046/201409/062332066723665.jpg"&gt;&lt;img title="RadiaGradient" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="RadiaGradient" src="http://images.cnitblog.com/blog/62046/201409/062332070328621.jpg" width="260" height="480"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;扩展--渐变填充&lt;/h3&gt;
&lt;p&gt;上面我们只是绘制渐变到图形上下文，实际开发中有时候我们还需要填充对应的渐变色，例如现在绘制了一个矩形，如何填充成渐变色呢？在此可以利用渐变裁切来完成（当然利用层CALayer更加方便但这不在今天的话题讨论范围内），特别说明一下区域裁切并不仅仅适用于渐变填充，对于其他图形绘制仍然适用，并且注意裁切只能限于矩形裁切。&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRectWithLinearGradientFill:(CGContextRef)context{
    CGColorSpaceRef colorSpace=CGColorSpaceCreateDeviceRGB();
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//裁切处一块矩形用于显示，注意必须先裁切再调用渐变
    //CGContextClipToRect(context, CGRectMake(20, 50, 280, 300));
    //裁切还可以使用UIKit中对应的方法
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIRectClip(CGRectMake(20, 50, 280, 300));
    
    CGFloat compoents[12]={
        248.0/255.0,86.0/255.0,86.0/255.0,1,
        249.0/255.0,127.0/255.0,127.0/255.0,1,
        1.0,1.0,1.0,1.0
    };
    CGFloat locations[3]={0,0.3,1.0};
    CGGradientRef gradient= CGGradientCreateWithColorComponents(colorSpace, compoents, locations, 3);

    CGContextDrawLinearGradient(context, gradient, CGPointMake(20, 50), CGPointMake(300, 300), kCGGradientDrawsAfterEndLocation);
    
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//释放颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRelease(colorSpace);
}&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332072503322.jpg"&gt;&lt;img title="ClipRectEffect" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="ClipRectEffect" src="http://images.cnitblog.com/blog/62046/201409/062332078604735.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h2&gt;其他状态设置&lt;/h2&gt;
&lt;p&gt;常用的图形上下文状态设置上面基本都用到了，我们不再一一解释，这里着重说一下叠加模式和填充模式，初学者对于这两个状态设置往往容易产生疑惑。&lt;/p&gt;
&lt;h3&gt;叠加模式&lt;/h3&gt;
&lt;p&gt;使用Quartz 2D绘图时后面绘制的图像会覆盖前面的，默认情况下如果前面的被覆盖后将看不到后面的内容，但是有时候这个结果并不是我们想要的，因此在Quartz 2D中提供了填充模式供开发者配置调整。由于填充模式类别特别多，因此下面以一个例子来说明：&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRectByUIKitWithContext2:(CGContextRef)context{
    CGRect rect= CGRectMake(0, 130.0, 320.0, 50.0);
    CGRect rect1= CGRectMake(0, 390.0, 320.0, 50.0);
    
    
    CGRect rect2=CGRectMake(20, 50.0, 10.0, 250.0);
    CGRect rect3=CGRectMake(40.0, 50.0, 10.0, 250.0);
    CGRect rect4=CGRectMake(60.0, 50.0, 10.0, 250.0);
    CGRect rect5=CGRectMake(80.0, 50.0, 10.0, 250.0);
    CGRect rect6=CGRectMake(100.0, 50.0, 10.0, 250.0);
    CGRect rect7=CGRectMake(120.0, 50.0, 10.0, 250.0);
    CGRect rect8=CGRectMake(140.0, 50.0, 10.0, 250.0);
    CGRect rect9=CGRectMake(160.0, 50.0, 10.0, 250.0);
    CGRect rect10=CGRectMake(180.0, 50.0, 10.0, 250.0);
    CGRect rect11=CGRectMake(200.0, 50.0, 10.0, 250.0);
    CGRect rect12=CGRectMake(220.0, 50.0, 10.0, 250.0);
    CGRect rect13=CGRectMake(240.0, 50.0, 10.0, 250.0);
    CGRect rect14=CGRectMake(260.0, 50.0, 10.0, 250.0);
    CGRect rect15=CGRectMake(280.0, 50.0, 10.0, 250.0);
    
    CGRect rect16=CGRectMake(30.0, 310.0, 10.0, 250.0);
    CGRect rect17=CGRectMake(50.0, 310.0, 10.0, 250.0);
    CGRect rect18=CGRectMake(70.0, 310.0, 10.0, 250.0);
    CGRect rect19=CGRectMake(90.0, 310.0, 10.0, 250.0);
    CGRect rect20=CGRectMake(110.0, 310.0, 10.0, 250.0);
    CGRect rect21=CGRectMake(130.0, 310.0, 10.0, 250.0);
    CGRect rect22=CGRectMake(150.0, 310.0, 10.0, 250.0);
    CGRect rect23=CGRectMake(170.0, 310.0, 10.0, 250.0);
    CGRect rect24=CGRectMake(190.0, 310.0, 10.0, 250.0);
    CGRect rect25=CGRectMake(210.0, 310.0, 10.0, 250.0);
    CGRect rect26=CGRectMake(230.0, 310.0, 10.0, 250.0);
    CGRect rect27=CGRectMake(250.0, 310.0, 10.0, 250.0);
    CGRect rect28=CGRectMake(270.0, 310.0, 10.0, 250.0);
    CGRect rect29=CGRectMake(290.0, 310.0, 10.0, 250.0);

    
    [[UIColor yellowColor]set];
    UIRectFill(rect);
    
    [[UIColor greenColor]setFill];
    UIRectFill(rect1);
    
    [[UIColor redColor]setFill];
    UIRectFillUsingBlendMode(rect2, kCGBlendModeClear);
    UIRectFillUsingBlendMode(rect3, kCGBlendModeColor);
    UIRectFillUsingBlendMode(rect4, kCGBlendModeColorBurn);
    UIRectFillUsingBlendMode(rect5, kCGBlendModeColorDodge);
    UIRectFillUsingBlendMode(rect6, kCGBlendModeCopy);
    UIRectFillUsingBlendMode(rect7, kCGBlendModeDarken);
    UIRectFillUsingBlendMode(rect8, kCGBlendModeDestinationAtop);
    UIRectFillUsingBlendMode(rect9, kCGBlendModeDestinationIn);
    UIRectFillUsingBlendMode(rect10, kCGBlendModeDestinationOut);
    UIRectFillUsingBlendMode(rect11, kCGBlendModeDestinationOver);
    UIRectFillUsingBlendMode(rect12, kCGBlendModeDifference);
    UIRectFillUsingBlendMode(rect13, kCGBlendModeExclusion);
    UIRectFillUsingBlendMode(rect14, kCGBlendModeHardLight);
    UIRectFillUsingBlendMode(rect15, kCGBlendModeHue);
    UIRectFillUsingBlendMode(rect16, kCGBlendModeLighten);
    
    UIRectFillUsingBlendMode(rect17, kCGBlendModeLuminosity);
    UIRectFillUsingBlendMode(rect18, kCGBlendModeMultiply);
    UIRectFillUsingBlendMode(rect19, kCGBlendModeNormal);
    UIRectFillUsingBlendMode(rect20, kCGBlendModeOverlay);
    UIRectFillUsingBlendMode(rect21, kCGBlendModePlusDarker);
    UIRectFillUsingBlendMode(rect22, kCGBlendModePlusLighter);
    UIRectFillUsingBlendMode(rect23, kCGBlendModeSaturation);
    UIRectFillUsingBlendMode(rect24, kCGBlendModeScreen);
    UIRectFillUsingBlendMode(rect25, kCGBlendModeSoftLight);
    UIRectFillUsingBlendMode(rect26, kCGBlendModeSourceAtop);
    UIRectFillUsingBlendMode(rect27, kCGBlendModeSourceIn);
    UIRectFillUsingBlendMode(rect28, kCGBlendModeSourceOut);
    UIRectFillUsingBlendMode(rect29, kCGBlendModeXOR);
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332083284892.jpg"&gt;&lt;img title="BlendModeEffect" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="BlendModeEffect" src="http://images.cnitblog.com/blog/62046/201409/062332086722321.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;相信大家对比代码和显示效果并不难发现每种叠加的效果。例子中只是使用UIKit的封装方法进行叠加模式设置，更一般的方法当然是使用&lt;strong&gt;CGContextSetBlendMode(CGContextRef context, CGBlendMode mode)&lt;/strong&gt;方法进行设置。&lt;/p&gt;
&lt;h3&gt;填充模式&lt;/h3&gt;
&lt;p&gt;前面的示例中已经演示过纯色填充、渐变填充，而有时我们需要按一定的自定义样式进行填充，这种方式有点类似于贴瓷砖的方式。我们知道如果家里贴地板或瓷砖时，通常我们会先选择一种瓷砖样式，根据房间面积我们购买不同量的瓷砖。但是不管买多少，这些瓷砖的样式都是一模一样的。填充模式就是为了达到这种效果而产生的：我们只需要绘制一个瓷砖的样式，然后让程序自动调用这种样式填充指定大小的区域。&lt;/p&gt;
&lt;p&gt;Quartz 2D支持两种填充模式：有颜色填充和无颜色填充。两种模式使用起来区别很小，有颜色填充就是在绘制瓷砖时就指定颜色，在调用填充时就不用再指定瓷砖颜色；无颜色填充模式就是绘制瓷砖时不用指定任何颜色，在调用填充时再指定具体填充颜色。相比较无颜色填充模式而言，有颜色填充模式更加的灵活，推荐使用。&lt;/p&gt;
&lt;p&gt;下面我们具体看一下如何按指定模式进行图形填充：&lt;/p&gt;
&lt;p&gt;1.在使用填充模式时首先要构建一个符合CGPatternDrawPatternCallback签名的方法，这个方法专门用来创建“瓷砖”。注意：如果使用有颜色填充模式，需要设置填充色。例如我们定义一个方法drawTile绘制以下瓷砖（有颜色填充）：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332089227777.png"&gt;&lt;img title="Tile" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="Tile" src="http://images.cnitblog.com/blog/62046/201409/062332091105020.png" width="40" height="40"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2.接着需要指定一个填充的颜色空间，这个颜色空间跟前面绘制渐变的颜色空间不太一样，前面创建渐变使用的颜色空间是设备无关的，我们需要基于这个颜色空间创建一个颜色空间专门用于填充（注意对于有颜色填充创建填充颜色空间参数为NULL，不用基于设备无关的颜色空间创建）。&lt;/p&gt;
&lt;p&gt;3.然后我们就可以使用CGPatternCreate方法创建一个填充模式，创建填充模式时需要注意其中的参数，在代码中已经做了一一解释（这里注意对于有颜色填充模式isColored设置为true，否则为false）。&lt;/p&gt;
&lt;p&gt;4.最后调用CGContextSetFillPattern方法给图形上下文指定填充模式（这个时候注意最后一个参数，如果是有颜色填充模式最后一个参数为透明度alpa的地址，对于无颜色填充模式最后一个参数是当前填充颜色空间的颜色数组）。&lt;/p&gt;
&lt;p&gt;5.绘制图形，这里我们绘制一个矩形。&lt;/p&gt;
&lt;p&gt;6.释放资源。&lt;/p&gt;
&lt;p&gt;下面是具体代码（包含两种填充模式代码，可以一一运行）&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  UIView4.m
//  Quartz2D
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#define &lt;/span&gt;&lt;span style="background: white; color: black"&gt;TILE_SIZE 20

@implementation KCView

-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRect:(CGRect)rect{
    CGContextRef context=UIGraphicsGetCurrentContext();
    [self drawBackgroundWithColoredPattern:context];
&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//    [self drawBackgroundWithPattern:context];
    
&lt;/span&gt;&lt;span style="background: white; color: black"&gt;}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark - 有颜色填充模式
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void &lt;/span&gt;&lt;span style="background: white; color: black"&gt;drawColoredTile(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void &lt;/span&gt;&lt;span style="background: white; color: black"&gt;*info,CGContextRef context){
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//有颜色填充，这里设置填充色
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetRGBFillColor(context, 254.0/255.0, 52.0/255.0, 90.0/255.0, 1);
    CGContextFillRect(context, CGRectMake(0, 0, TILE_SIZE, TILE_SIZE));
    CGContextFillRect(context, CGRectMake(TILE_SIZE, TILE_SIZE, TILE_SIZE, TILE_SIZE));
}
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawBackgroundWithColoredPattern:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设备无关的颜色空间
//    CGColorSpaceRef rgbSpace= CGColorSpaceCreateDeviceRGB();
    //模式填充颜色空间,注意对于有颜色填充模式，这里传NULL
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRef colorSpace=CGColorSpaceCreatePattern(NULL);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//将填充色颜色空间设置为模式填充的颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetFillColorSpace(context, colorSpace);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//填充模式回调函数结构体
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGPatternCallbacks callback={0,&amp;amp;drawColoredTile,NULL};
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*填充模式
     info://传递给callback的参数
     bounds:瓷砖大小
     matrix:形变
     xStep:瓷砖横向间距
     yStep:瓷砖纵向间距
     tiling:贴砖的方法
     isClored:绘制的瓷砖是否已经指定了颜色(对于有颜色瓷砖此处指定位true)
     callbacks:回调函数
     */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGPatternRef pattern=CGPatternCreate(NULL, CGRectMake(0, 0, 2*TILE_SIZE, 2*TILE_SIZE), CGAffineTransformIdentity,2*TILE_SIZE+ 5,2*TILE_SIZE+ 5, kCGPatternTilingNoDistortion, &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;true&lt;/span&gt;&lt;span style="background: white; color: black"&gt;, &amp;amp;callback);
    
    CGFloat alpha=1;
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//注意最后一个参数对于有颜色瓷砖指定为透明度的参数地址，对于无颜色瓷砖则指定当前颜色空间对应的颜色数组
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetFillPattern(context, pattern, &amp;amp;alpha);
    
    UIRectFill(CGRectMake(0, 0, 320, 568));
    
&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//    CGColorSpaceRelease(rgbSpace);
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRelease(colorSpace);
    CGPatternRelease(pattern);
}


&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark - 无颜色填充模式
&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//填充瓷砖的回调函数（必须满足CGPatternCallbacks签名）
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void &lt;/span&gt;&lt;span style="background: white; color: black"&gt;drawTile(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void &lt;/span&gt;&lt;span style="background: white; color: black"&gt;*info,CGContextRef context){
    CGContextFillRect(context, CGRectMake(0, 0, TILE_SIZE, TILE_SIZE));
    CGContextFillRect(context, CGRectMake(TILE_SIZE, TILE_SIZE, TILE_SIZE, TILE_SIZE));
}
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawBackgroundWithPattern:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设备无关的颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRef rgbSpace= CGColorSpaceCreateDeviceRGB();
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//模式填充颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGColorSpaceRef colorSpace=CGColorSpaceCreatePattern(rgbSpace);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//将填充色颜色空间设置为模式填充的颜色空间
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetFillColorSpace(context, colorSpace);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//填充模式回调函数结构体
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGPatternCallbacks callback={0,&amp;amp;drawTile,NULL};
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;/*填充模式
     info://传递给callback的参数
     bounds:瓷砖大小
     matrix:形变
     xStep:瓷砖横向间距
     yStep:瓷砖纵向间距
     tiling:贴砖的方法（瓷砖摆放的方式）
     isClored:绘制的瓷砖是否已经指定了颜色（对于无颜色瓷砖此处指定位false）
     callbacks:回调函数
     */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGPatternRef pattern=CGPatternCreate(NULL, CGRectMake(0, 0, 2*TILE_SIZE, 2*TILE_SIZE), CGAffineTransformIdentity,2*TILE_SIZE+ 5,2*TILE_SIZE+ 5, kCGPatternTilingNoDistortion, &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;false&lt;/span&gt;&lt;span style="background: white; color: black"&gt;, &amp;amp;callback);
    
    CGFloat components[]={254.0/255.0,52.0/255.0,90.0/255.0,1.0};
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//注意最后一个参数对于无颜色填充模式指定为当前颜色空间颜色数据
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSetFillPattern(context, pattern, components);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//    CGContextSetStrokePattern(context, pattern, components);
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIRectFill(CGRectMake(0, 0, 320, 568));
    
    CGColorSpaceRelease(rgbSpace);
    CGColorSpaceRelease(colorSpace);
    CGPatternRelease(pattern);
}
@end&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332100941320.jpg"&gt;&lt;img title="FillWithPattern" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="FillWithPattern" src="http://images.cnitblog.com/blog/62046/201409/062332105943234.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这里强调一点，在drawTile回调方法中不要使用UIKit封装方法进行图形绘制（例如UIRectFill等），由于这个方法由Core Graphics内部调用，而Core Graphics考虑到跨平台问题，内部是不允许调用UIKit方法的。&lt;/p&gt;
&lt;h2&gt;上下文变换&lt;/h2&gt;
&lt;p&gt;我们知道在UIKit开发中UIView有一个transform属性用于控件的形变，其实在绘图中我们也经常用到图形形变，这个时候可以借助图形上下文的形变方法来完成。在弄清形变之前我们要清楚图形上下文的坐标原点，因为无论是位移还是旋转都是相对于坐标原点进行的。其实Quartz 2D的坐标系同UIKit并不一样，它的坐标原点在屏幕左下方，但是为了统一编程方式，UIKit对其进行了转换，坐标原点统一在屏幕左上角。注意在设置图形上下文形变之前一定要注意保存上下文的初始状态，在使用完之后进行恢复。否则在处理多个图形形变的时候很容易弄不清楚到底是基于怎样的坐标系进行绘图，容易找不到原点（做过html5 canvas绘图的朋友对这一点应该很熟悉，在html5中绘图也经常进行状态保存和恢复）。下面通过一个图片的变换演示一下图形上下文的形变（其他图形也是一样的，就不再演示）：&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCView2.m
//  Quartz2D
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView2.h"

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@implementation KCView2

-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRect:(CGRect)rect{
    CGContextRef context=UIGraphicsGetCurrentContext();
    [self drawImage:context];
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 图形上下文形变
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawImage:(CGContextRef)context{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//保存初始状态
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextSaveGState(context);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//形变第一步：图形上下文向右平移40
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextTranslateCTM(context, 100, 0);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//形变第二步：缩放0.8
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextScaleCTM(context, 0.8, 0.8);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//形变第三步：旋转
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextRotateCTM(context, M_PI_4/4);
    
    UIImage *image=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"photo1.jpg"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    [image drawInRect:CGRectMake(0, 50, 240, 300)];
    
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//恢复到初始状态
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextRestoreGState(context);
}

@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;最终运行效果见第四幅截图，下图描绘出了整个程序的运行过程（移动-&amp;gt;缩放-&amp;gt;旋转）：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332111411134.png"&gt;&lt;img title="CGContentRefState" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="CGContentRefState" src="http://images.cnitblog.com/blog/62046/201409/062332136886689.png" width="800" height="1223"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;扩展--使用Core Graphics绘制图像&lt;/h2&gt;
&lt;p&gt;在前面基本绘图部分，绘制图像时使用了UIKit中封装的方法进行了图像绘制，我们不妨看一下使用Quartz 2D内置方法绘制是什么效果。&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawImage2:(CGContextRef)context{
    UIImage *image=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"image2.jpg"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//图像绘制
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGRect rect= CGRectMake(10, 50, 300, 450);
    CGContextDrawImage(context, rect, image.CGImage);
}&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/091535232625836.jpg"&gt;&lt;img title="DrawImage2Effect" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawImage2Effect" src="http://images.cnitblog.com/blog/62046/201409/091535241684394.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;看起来整个图像是倒过来的，原因正是前面说的：在Core Graphics中坐标系的y轴正方向是向上的，坐标原点在屏幕左下角，y轴方向刚好和UIKit中y轴方向相反。而使用UIKit进行绘图之所以没有问题是因为UIKit中进行了处理，事实上对于其他图形即使使用Core Graphics绘制也没有问题，因为UIKit统一了编程方式。但是使用Core Graphics中内置方法绘制图像是存在这种问题的，如何解决呢？&lt;/p&gt;
&lt;p&gt;其实图形上下文只要沿着x轴旋转180度，然后向上平移适当的高度即可（但是注意不要沿着z轴旋转，这样得不到想要的结果）。可是通过前面介绍的&lt;span style="background: white; color: green"&gt;&lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextRotateCTM方法只能通过沿着z轴旋转，此时不妨使用另外一种方法，那就是在y轴方向缩放-1，同样可以达到想要的效果：&lt;/span&gt;&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: black"&gt;-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawImage2:(CGContextRef)context{
    UIImage *image=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"image2.jpg"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    CGSize size=[UIScreen mainScreen].bounds.size;
    CGContextSaveGState(context);
    CGFloat height=450,y=50;
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//上下文形变
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextScaleCTM(context, 1.0, -1.0);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//在y轴缩放-1相当于沿着x张旋转180
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextTranslateCTM(context, 0, -(size.height-(size.height-2*y-height)));&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//向上平移
    //图像绘制
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGRect rect= CGRectMake(10, y, 300, height);
    CGContextDrawImage(context, rect, image.CGImage);
    
    CGContextRestoreGState(context);
}&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;h1 id="refreshView"&gt;视图刷新&lt;/h1&gt;
&lt;p&gt;在UIView的drawRect:中绘制的图形会在控件显示的时候调用（而且显示时会重绘所有图形），有时候我们希望绘制内容的显示是实时的，此时我们就需要调用绘图方法重新绘制，但是在iOS开发中不允许开发者直接调用drawRect:方法，刷新绘制内容需要调用setNeedsDisplay方法。下面以一个调整字体大小的界面演示一下视图的刷新。&lt;/p&gt;
&lt;p&gt;KCView.h&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCView.h
//  RefreshView
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;&amp;lt;UIKit/UIKit.h&amp;gt;

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;interface &lt;/span&gt;&lt;span style="background: white; color: black"&gt;KCView : UIView

@&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;property &lt;/span&gt;&lt;span style="background: white; color: black"&gt;(nonatomic,copy) NSString *title;

@&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;property &lt;/span&gt;&lt;span style="background: white; color: black"&gt;(nonatomic,assign) CGFloat fontSize;

@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;KCView.m&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCView.m
//  RefreshView
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView.h"

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@implementation KCView

-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawRect:(CGRect)rect{
    
    NSString *str=_title;
    UIFont *font=[UIFont fontWithName:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Marker Felt" &lt;/span&gt;&lt;span style="background: white; color: black"&gt;size:_fontSize];
    UIColor *foreignColor=[UIColor redColor];
    [str drawInRect:CGRectMake(100, 120, 300, 200) withAttributes:@{NSFontAttributeName:font,NSForegroundColorAttributeName:foreignColor}];
}

@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;KCMainViewController.m&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCMainViewController.m
//  RefreshView
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCMainViewController.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView.h"

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;interface &lt;/span&gt;&lt;span style="background: white; color: black"&gt;KCMainViewController ()&amp;lt;UIPickerViewDataSource,UIPickerViewDelegate&amp;gt;{
    KCView *_contentView;
    NSArray *_fontSize;
}

@end

@implementation KCMainViewController

- (&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)viewDidLoad {
    [super viewDidLoad];
    
    [self initLayout];
    
    [self addPickerView];
}

-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)initLayout{
    _fontSize=@[@15,@18,@20,@22,@25,@28,@30,@32,@35,@40];
    _contentView=[[KCView alloc]initWithFrame:CGRectMake(0, 0, 320, 300)];
    _contentView.backgroundColor=[UIColor whiteColor];
    _contentView.title=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Hello world!"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    _contentView.fontSize=[_fontSize[0] intValue];
    [self.view addSubview:_contentView];
}

-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)addPickerView{
    UIPickerView *picker=[[UIPickerView alloc]initWithFrame:CGRectMake(0, 300, 320, 268)];
    picker.dataSource=self;
    picker.&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;delegate&lt;/span&gt;&lt;span style="background: white; color: black"&gt;=self;
    
    [self.view addSubview:picker];
}

-(NSInteger)numberOfComponentsInPickerView:(UIPickerView *)pickerView{
    &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;return &lt;/span&gt;&lt;span style="background: white; color: black"&gt;1;
}
-(NSInteger)pickerView:(UIPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component{
    &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;return &lt;/span&gt;&lt;span style="background: white; color: black"&gt;_fontSize.count;
}

-(NSString *)pickerView:(UIPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component{
    &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;return &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[NSString stringWithFormat:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"%@号字体"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;,_fontSize[row] ];
}
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)pickerView:(UIPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component{
    _contentView.fontSize=[[_fontSize objectAtIndex:row] intValue];
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//刷新视图
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[_contentView setNeedsDisplay];
}
@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332161724030.gif"&gt;&lt;img title="RefreshViewEffect" style="display: inline" alt="RefreshViewEffect" src="http://images.cnitblog.com/blog/62046/201409/062332165473215.gif"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;h1 id="otherCGContext"&gt;其他图形上下文 &lt;/h1&gt;
&lt;p&gt;前面我们也说过，Quartz 2D的图形上下方除了可以绘制到层上还可以绘制到位图、PDF等，这里我们就介绍一下如何利用Quartz 2D绘制图像到位图及PDF中。&lt;/p&gt;
&lt;p&gt;上面的示例中一直都是在drawRect:方法中利用UIGraphicsGetCurrentContext()方法取得上下文，要得到位图或者PDF的上下文可以利用UIGraphicsBeginImageContext(CGSize size)和UIGraphicsBeginPDFPageWithInfo(CGRect bounds, NSDictionary *pageInfo)方法。位图图形上下文和PDF图形上下文UIKit是不会负责创建的，所以需要用户手动创建，并且在使用完后关闭它。在使用UIKit中系统创建的图形上下文的时候，我们只能在drawRect：方法中使用，由于这两类图形上下文是由我们手动创建的因此可以放到任何方法中调用。此外，这两个方法开启的图形上下文并没有返回值，如果我们要得到我们创建的图形上下文只要在创建上下文之后、关闭之前调用UIGraphicsGetCurrentContext()方法，此时取得的上下文即是我们自己创建的图形上下文。&lt;/p&gt;
&lt;h3&gt;绘制到位图&lt;/h3&gt;
&lt;p&gt;下面利用位图图形上下文给一个图片添加水印，在下面的程序中我们首先创建上下文，然后在上下文中绘制图片、直线和文本，最后从当前位图上下文中取得最终形成的新图片显示到界面。&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCMainViewController.m
//  Quartz2D
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;&amp;lt;CoreText/CoreText.h&amp;gt;
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCMainViewController.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView2.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView3.h"

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;interface &lt;/span&gt;&lt;span style="background: white; color: black"&gt;KCMainViewController ()

@end

@implementation KCMainViewController

- (&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)viewDidLoad {
    [super viewDidLoad];

    UIImage *image=[self drawImageAtImageContext];
    UIImageView *imageView=[[UIImageView alloc]initWithImage:image];
    imageView.center=CGPointMake(160, 284);
    
    [self.view addSubview:imageView];
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 利用位图上下文添加水印效果
-(UIImage *)drawImageAtImageContext{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//获得一个位图图形上下文
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGSize size=CGSizeMake(300, 188);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//画布大小
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIGraphicsBeginImageContext(size);
    
    UIImage *image=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"photo2.png"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    [image drawInRect:CGRectMake(0, 0, 300, 188)];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//注意绘图的位置是相对于画布顶点而言，不是屏幕
    
    
    //添加水印
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGContextRef context=UIGraphicsGetCurrentContext();
    CGContextMoveToPoint(context, 200, 178);
    CGContextAddLineToPoint(context, 270, 178);
    
    [[UIColor redColor]setStroke];
    CGContextSetLineWidth(context, 2);
    
    CGContextDrawPath(context, kCGPathStroke);
    
    NSString *str=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Kenshin Cui"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    [str drawInRect:CGRectMake(200, 158, 100, 30) withAttributes:@{NSFontAttributeName:[UIFont fontWithName:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Marker Felt" &lt;/span&gt;&lt;span style="background: white; color: black"&gt;size:15],NSForegroundColorAttributeName:[UIColor redColor]}];
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//返回绘制的新图形
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIImage *newImage=UIGraphicsGetImageFromCurrentImageContext();
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//最后一定不要忘记关闭对应的上下文
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIGraphicsEndImageContext();
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//保存图片
//    NSData *data= UIImagePNGRepresentation(newImage);
//    [data writeToFile:@"/Users/kenshincui/Desktop/myPic.png" atomically:YES];
    
    &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;return &lt;/span&gt;&lt;span style="background: white; color: black"&gt;newImage;
}

@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332172827356.jpg"&gt;&lt;img title="ImageContextEffect" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="ImageContextEffect" src="http://images.cnitblog.com/blog/62046/201409/062332175631272.jpg" width="320" height="590"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;注意：上面这种方式绘制的图像除了可以显示在界面上还可以调用对应方法进行保存（代码注释中已经包含保存方法）；除此之外这种方法相比在drawRect：方法中绘制图形效率更高，它不用每次展示时都调用所有图形绘制方法。&lt;/p&gt;
&lt;h3&gt;绘制到PDF&lt;/h3&gt;
&lt;p&gt;绘制到PDF则要启用pdf图形上下文，PDF图形上下文的创建使用方式跟位图图形上下文是类似的，需要注意的一点就是绘制内容到PDF时需要创建分页，每页内容的开始都要调用一次&lt;strong&gt;IGraphicsBeginPDFPage();&lt;/strong&gt;方法。下面的示例演示了文本绘制和图片绘制（其他图形绘制也是类似的）：&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCMainViewController.m
//  Quartz2D
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;&amp;lt;CoreText/CoreText.h&amp;gt;
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCMainViewController.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCView2.h"

&lt;/span&gt;&lt;span style="background: white; color: black"&gt;@&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;interface &lt;/span&gt;&lt;span style="background: white; color: black"&gt;KCMainViewController ()

@end

@implementation KCMainViewController

- (&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)viewDidLoad {
    [super viewDidLoad];

    [self drawContentToPdfContext];
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 利用pdf图形上下文绘制内容到pdf文档
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)drawContentToPdfContext{
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//沙盒路径（也就是我们应用程序文件运行的路径）
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;NSArray *paths=NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *path=[[paths firstObject] stringByAppendingPathComponent:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"myPDF.pdf"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    NSLog(@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"%@"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;,path);
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//启用pdf图形上下文
    /**
     path:保存路径
     bounds:pdf文档大小，如果设置为CGRectZero则使用默认值：612*792
     pageInfo:页面设置,为nil则不设置任何信息
     */
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIGraphicsBeginPDFContextToFile(path,CGRectZero,[NSDictionary dictionaryWithObjectsAndKeys:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Kenshin Cui"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;,kCGPDFContextAuthor, nil]);
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//由于pdf文档是分页的，所以首先要创建一页画布供我们绘制
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIGraphicsBeginPDFPage();&lt;/span&gt;&lt;span style="background: white; color: green"&gt;
    
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;NSString *title=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Welcome to Apple Support"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    NSMutableParagraphStyle *style=[[NSMutableParagraphStyle alloc]init];
    NSTextAlignment align=NSTextAlignmentCenter;
    style.alignment=align;
    [title drawInRect:CGRectMake(26, 20, 300, 50) withAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:18],NSParagraphStyleAttributeName:style}];
    NSString *content=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Learn about Apple products, view online manuals, get the latest downloads, and more. Connect with other Apple users, or get service, support, and professional advice from Apple."&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    NSMutableParagraphStyle *style2=[[NSMutableParagraphStyle alloc]init];
    style2.alignment=NSTextAlignmentLeft;
&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//    style2.firstLineHeadIndent=20;
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[content drawInRect:CGRectMake(26, 56, 300, 255) withAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:15],NSForegroundColorAttributeName:[UIColor grayColor],NSParagraphStyleAttributeName:style2}];
    
    UIImage *image=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"applecare_folks_tall.png"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    [image drawInRect:CGRectMake(316, 20, 290, 305)];
    
    UIImage *image2=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"applecare_page1.png"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    [image2 drawInRect:CGRectMake(6, 320, 600, 281)];
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//创建新的一页继续绘制其他内容
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIGraphicsBeginPDFPage();
    UIImage *image3=[UIImage imageNamed:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"applecare_page2.png"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    [image3 drawInRect:CGRectMake(6, 20, 600, 629)];
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//结束pdf上下文
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIGraphicsEndPDFContext();
}
@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;生成的pdf文档：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332179859741.png"&gt;&lt;img title="DrawToPDF" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="DrawToPDF" src="http://images.cnitblog.com/blog/62046/201409/062332189854569.png" width="800" height="423"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知识补充&lt;/p&gt;
&lt;p&gt;1.Core Graphics是基于C语言的一套框架，开发时无法像使用Obj-C一样调用；&lt;/p&gt;
&lt;p&gt;2.在Quartz 2D中凡是使用带有“Create”或者“Copy”关键字方法创建的对象，在使用后一定要使用对应的方法释放（由于这个框架基于C语言编写无法自动释放内存）；&lt;/p&gt;
&lt;p&gt;3.Quartz 2D是跨平台的，因此其中的方法中不能使用UIKit中的对象（UIKit只有iOS可用），例如用到的颜色只能用CGColorRef而不能用UIColor，但是UIKit中提供了对应的转换方法；&lt;/p&gt;
&lt;p&gt;4.在C语言中枚举一般以“k”开头，由于Quartz 2D基于C语言开发，所以它也不例外（参数中很多枚举都是k开头的）；&lt;/p&gt;
&lt;p&gt;5.由于Quartz 2D是Core Graphics的一部分，所以API多数以CG开头；&lt;/p&gt;
&lt;p&gt;6.在使用Quartz 2D绘图API中所有以“Ref”结尾对象，在声明时都不必声明为指针类型；&lt;/p&gt;
&lt;p&gt;7.在使用Quartz 2D绘图API时，凡是“UI”开头的相关绘图函数，都是UIKit对Core Graphics的封装（主要为了简化绘图操作）；&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;
&lt;p&gt;
&lt;p&gt;
&lt;h1 id="coreImage"&gt;Core Image&lt;/h1&gt;
&lt;p&gt;利用Quartz 2D我们可以绘制各类图形、图像，功能确实强大。用过photoshop的朋友都知道，使用photoshop可以制作各种滤镜特效，那么在iOS中能否实现滤镜呢？在iOS5.0之前这些算法基本全部要靠程序员编程实现，实现过程相当复杂。从iOS5.0开始苹果官方已经提供了Core Image框架来帮助开发者进行特效制作。&lt;/p&gt;
&lt;p&gt;先来看一下滤镜使用过程中常用的基类对象：&lt;/p&gt;
&lt;p&gt;CIContext：图像上下文，用于管理整个图片处理过程，不同的图形上下文将利用不同的图像处理硬件进行图像处理（在iOS中可以通过不同的方式创建图像上下文，例如可以创建基于CPU的图像上下方、创建基于GPU的图像上下方以及创建OpenGL优化过的图像上下文）。&lt;/p&gt;
&lt;p&gt;CIFilter：图像处理滤镜，每种滤镜有不同的参数设置。&lt;/p&gt;
&lt;p&gt;CIImage：Core Image框架中的图像类型，主要用于输入和输出图像。&lt;/p&gt;
&lt;p&gt;在使用滤镜之前我们先要弄清平台主要支持哪些滤镜，以及这些滤镜的方法和参数如何设置，此时不妨使用下面的方法进行打印查看：&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 查看所有内置滤镜
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)showAllFilters{
    NSArray *filterNames=[CIFilter filterNamesInCategory:kCICategoryBuiltIn];
    &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;for &lt;/span&gt;&lt;span style="background: white; color: black"&gt;(NSString *filterName in filterNames) {
        CIFilter *filter=[CIFilter filterWithName:filterName];
        NSLog(@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"\rfilter:%@\rattributes:%@"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;,filterName,[filter attributes]);
    }
}&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;在iOS7中打印会发现有127中滤镜，如果我们把每种滤镜都介绍一遍恐怕用几章内容也很难介绍详细，事实上也没有这个必要。这些滤镜使用方法是类似的，只是参数设置有所区别。在iOS文档中可以搜索“core image filter reference”一节的内容，里面有每种滤镜的详细介绍和图片使用效果。&lt;/p&gt;
&lt;p&gt;使用Core Image框架创建滤镜效果一般分为以下几步：&lt;/p&gt;
&lt;p&gt;1.创建图像上下文CIContext&lt;/p&gt;
&lt;p&gt;2.创建滤镜CIFilter&lt;/p&gt;
&lt;p&gt;3.创建过滤原图片CIImage&lt;/p&gt;
&lt;p&gt;4.调用CIFilter的&lt;strong&gt;setValue： forKey：&lt;/strong&gt;方法为滤镜指定源图片&lt;/p&gt;
&lt;p&gt;5.设置滤镜参数【可选】&lt;/p&gt;
&lt;p&gt;6.取得输出图片显示或保存&lt;/p&gt;
&lt;p&gt;大家都知道在美图秀秀中有一个“增强”功能，利用它可以调整照片的饱和度、亮度、对比度，其实在Core Image中也有这样一款滤镜，下面就以颜色滤镜来演示一下Core Image中滤镜的使用。&lt;/p&gt;&lt;pre class="code"&gt;&lt;span style="background: white; color: green"&gt;//
//  KCMainViewController.m
//  CoreImage
//
//  Created by Kenshin Cui on 14-3-17.
//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.
//

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#import &lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"KCMainViewController.h"
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#define &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CONSTROLPANEL_FONTSIZE 12

@&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;interface &lt;/span&gt;&lt;span style="background: white; color: black"&gt;KCMainViewController ()&amp;lt;UINavigationControllerDelegate,UIImagePickerControllerDelegate&amp;gt;{
    UIImagePickerController *_imagePickerController;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//系统照片选择控制器
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIImageView *_imageView;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//图片显示控件
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CIContext *_context;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//Core Image上下文
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CIImage *_image;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//我们要编辑的图像
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CIImage *_outputImage;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//处理后的图像
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CIFilter *_colorControlsFilter;&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//色彩滤镜
&lt;/span&gt;&lt;span style="background: white; color: black"&gt;}

@end

@implementation KCMainViewController

- (&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)viewDidLoad {
    [super viewDidLoad];
    
    [self initLayout];
}


&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 初始化布局
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)initLayout{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//初始化图片选择器
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;_imagePickerController=[[UIImagePickerController alloc]init];
    _imagePickerController.&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;delegate &lt;/span&gt;&lt;span style="background: white; color: black"&gt;=self;

    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//创建图片显示控件
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;_imageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 64, 320, 502)];
    _imageView.contentMode=UIViewContentModeScaleAspectFit;
    [self.view addSubview:_imageView];
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//上方导航按钮
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;self.navigationItem.title=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Enhance"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    self.navigationItem.leftBarButtonItem=[[UIBarButtonItem alloc]initWithTitle:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Open" &lt;/span&gt;&lt;span style="background: white; color: black"&gt;style:UIBarButtonItemStyleDone target:self action:@selector(openPhoto:)];
    self.navigationItem.rightBarButtonItem=[[UIBarButtonItem alloc]initWithTitle:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Save" &lt;/span&gt;&lt;span style="background: white; color: black"&gt;style:UIBarButtonItemStyleDone target:self action:@selector(savePhoto:)];

    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//下方控制面板
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIView *controlView=[[UIView alloc]initWithFrame:CGRectMake(0, 450, 320, 118)];
&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//    controlView.alpha=0.2;
//    controlView.backgroundColor=[UIColor colorWithRed:46.0/255.0 green:178.0/255.0 blue:235.0/255.0 alpha:1];
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[self.view addSubview:controlView];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//饱和度(默认为1，大于饱和度增加小于1则降低)
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UILabel *lbSaturation=[[UILabel alloc]initWithFrame:CGRectMake(10, 10, 60, 25)];
    lbSaturation.text=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Saturation"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    lbSaturation.font=[UIFont systemFontOfSize:CONSTROLPANEL_FONTSIZE];
    [controlView addSubview:lbSaturation];
    UISlider *sldStaturation=[[UISlider alloc]initWithFrame:CGRectMake(80, 10, 230, 30)];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//注意UISlider高度虽然无法调整，很多朋友会说高度设置位0即可，事实上在iOS7中设置为0后是无法拖动的
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[controlView addSubview:sldStaturation];
    sldStaturation.minimumValue=0;
    sldStaturation.maximumValue=2;
    sldStaturation.value=1;
    [sldStaturation addTarget:self action:@selector(changeStaturation:) forControlEvents:UIControlEventValueChanged];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//亮度(默认为0)
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UILabel *lbBrightness=[[UILabel alloc]initWithFrame:CGRectMake(10, 40, 60, 25)];
    lbBrightness.text=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Brightness"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    lbBrightness.font=[UIFont systemFontOfSize:CONSTROLPANEL_FONTSIZE];
    [controlView addSubview:lbBrightness];
    UISlider *sldBrightness=[[UISlider alloc]initWithFrame:CGRectMake(80, 40, 230, 30)];
    [controlView addSubview:sldBrightness];
    sldBrightness.minimumValue=-1;
    sldBrightness.maximumValue=1;
    sldBrightness.value=0;
    [sldBrightness addTarget:self action:@selector(changeBrightness:) forControlEvents:UIControlEventValueChanged];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//对比度(默认为1)
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UILabel *lbContrast=[[UILabel alloc]initWithFrame:CGRectMake(10, 70, 60, 25)];
    lbContrast.text=@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Contrast"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;;
    lbContrast.font=[UIFont systemFontOfSize:CONSTROLPANEL_FONTSIZE];
    [controlView addSubview:lbContrast];
    UISlider *sldContrast=[[UISlider alloc]initWithFrame:CGRectMake(80, 70, 230, 30)];
    [controlView addSubview:sldContrast];
    sldContrast.minimumValue=0;
    sldContrast.maximumValue=2;
    sldContrast.value=1;
    [sldContrast addTarget:self action:@selector(changeContrast:) forControlEvents:UIControlEventValueChanged];
    
    
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//初始化CIContext
    //创建基于CPU的图像上下文
    //    NSNumber *number=[NSNumber numberWithBool:YES];
    //    NSDictionary *option=[NSDictionary dictionaryWithObject:number forKey:kCIContextUseSoftwareRenderer];
    //    _context=[CIContext contextWithOptions:option];
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;_context=[CIContext contextWithOptions:nil];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//使用GPU渲染，推荐,但注意GPU的CIContext无法跨应用访问，例如直接在UIImagePickerController的完成方法中调用上下文处理就会自动降级为CPU渲染，所以推荐现在完成方法中保存图像，然后在主程序中调用
    //    EAGLContext *eaglContext=[[EAGLContext alloc]initWithAPI:kEAGLRenderingAPIOpenGLES1];
    //    _context=[CIContext contextWithEAGLContext:eaglContext];//OpenGL优化过的图像上下文
    
    //取得滤镜
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;_colorControlsFilter=[CIFilter filterWithName:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"CIColorControls"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];

}
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 打开图片选择器
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)openPhoto:(UIBarButtonItem *)btn{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//打开图片选择器
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[self presentViewController:_imagePickerController animated:YES completion:nil];
}
&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 保存图片
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)savePhoto:(UIBarButtonItem *)btn{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//保存照片到相册
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIImageWriteToSavedPhotosAlbum(_imageView.image, nil, nil, nil);
    UIAlertView *alert=[[UIAlertView alloc]initWithTitle:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Sytem Info" &lt;/span&gt;&lt;span style="background: white; color: black"&gt;message:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"Save Success!" &lt;/span&gt;&lt;span style="background: white; color: blue"&gt;delegate&lt;/span&gt;&lt;span style="background: white; color: black"&gt;:nil cancelButtonTitle:nil otherButtonTitles:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"OK"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;, nil];
    [alert show];
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 图片选择器选择图片代理方法
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info{
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//关闭图片选择器
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[self dismissViewControllerAnimated:YES completion:nil];
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//取得选择图片
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;UIImage *selectedImage=[info objectForKey:UIImagePickerControllerOriginalImage];
    _imageView.image=selectedImage;
    &lt;/span&gt;&lt;span style="background: white; color: green"&gt;//初始化CIImage源图像
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;_image=[CIImage imageWithCGImage:selectedImage.CGImage];
    [_colorControlsFilter setValue:_image forKey:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"inputImage"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置滤镜的输入图片
&lt;/span&gt;&lt;span style="background: white; color: black"&gt;}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 将输出图片设置到UIImageView
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)setImage{
    CIImage *outputImage= [_colorControlsFilter outputImage];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//取得输出图像
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGImageRef temp=[_context createCGImage:outputImage fromRect:[outputImage extent]];
    _imageView.image=[UIImage imageWithCGImage:temp];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//转化为CGImage显示在界面中
    
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;CGImageRelease(temp);&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//释放CGImage对象
&lt;/span&gt;&lt;span style="background: white; color: black"&gt;}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 调整饱和度
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)changeStaturation:(UISlider *)slider{
    [_colorControlsFilter setValue:[NSNumber numberWithFloat:slider.value] forKey:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"inputSaturation"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];&lt;/span&gt;&lt;span style="background: white; color: green"&gt;//设置滤镜参数
    &lt;/span&gt;&lt;span style="background: white; color: black"&gt;[self setImage];
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 调整亮度
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)changeBrightness:(UISlider *)slider{
    [_colorControlsFilter setValue:[NSNumber numberWithFloat:slider.value] forKey:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"inputBrightness"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    [self setImage];
}

&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;#pragma &lt;/span&gt;&lt;span style="background: white; color: black"&gt;mark 调整对比度
-(&lt;/span&gt;&lt;span style="background: white; color: blue"&gt;void&lt;/span&gt;&lt;span style="background: white; color: black"&gt;)changeContrast:(UISlider *)slider{
    [_colorControlsFilter setValue:[NSNumber numberWithFloat:slider.value] forKey:@&lt;/span&gt;&lt;span style="background: white; color: #a31515"&gt;"inputContrast"&lt;/span&gt;&lt;span style="background: white; color: black"&gt;];
    [self setImage];
}
@end&lt;/span&gt;&lt;/pre&gt;&lt;a href="http://11011.net/software/vspaste"&gt;&lt;/a&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://images.cnitblog.com/blog/62046/201409/062332199388113.gif"&gt;&lt;img title="CoreImageEffect" style="display: inline" alt="CoreImageEffect" src="http://images.cnitblog.com/blog/62046/201409/062332305784561.gif"&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;再次给大家强调一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在上面的代码中除了使用了基于GPU的图像上下文(推荐方式)，也创建了其他图像上下文，尽管已经被注释大家还是需要熟悉。 
&lt;li&gt;Core Image允许你一次给图像或视频帧叠加多种效果，同时Core Image还能保证强大的处理效率。 
&lt;li&gt;和在使用Core Graphics绘图一样，UIKit中也封装了一些方法直接转换为Core Image中的对象，例如UIImage对象可以直接调用CIImage属性转换为CIImage类型。&lt;/li&gt;&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div id="MySignature"&gt;&lt;/div&gt;
        &lt;div class="clear"&gt;&lt;/div&gt;
        &lt;div id="blog_post_info_block"&gt;
        &lt;div id="blog_post_info"&gt;
        &lt;/div&gt;
        &lt;div class="clear"&gt;&lt;/div&gt;
        &lt;div id="post_next_prev"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
    &lt;ul class="postmetadata"&gt;
        &lt;li class="icon_cat" id="BlogPostCategory"&gt;&lt;/li&gt;
        &lt;li class="icon_bullet" id="EntryTag"&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;var allowComments=true,isLogined=false,cb_blogId=79371,cb_entryId=3959951,cb_blogApp=currentBlogApp,cb_blogUserGuid='8c003886-9a30-de11-9510-001cf0cd104b',cb_entryCreatedDate='2014/9/6 23:33:00';loadViewCount(cb_entryId);&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var m = window.__blog.postRendered;
    if (m) { m(__$("post")); }
&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var m = window.__blog.postRenderPosts;
    if (m) { m(); }
&lt;/script&gt;
&lt;a name="!comments"&gt;&lt;/a&gt;&lt;div id="blog-comments-placeholder"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var commentManager = new blogCommentManager();commentManager.renderComments(0);&lt;/script&gt;
&lt;div id="comment_form" class="commentform"&gt;
&lt;a name="commentform"&gt;&lt;/a&gt;
&lt;div id="divCommentShow"&gt;&lt;/div&gt;
&lt;div id="comment_nav"&gt;&lt;span id="span_refresh_tips"&gt;&lt;/span&gt;&lt;a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();"&gt;刷新评论&lt;/a&gt;&lt;a href="#" onclick="return RefreshPage();"&gt;刷新页面&lt;/a&gt;&lt;a href="#top"&gt;返回顶部&lt;/a&gt;&lt;/div&gt;
&lt;div id="comment_form_container"&gt;&lt;/div&gt;
&lt;div class="ad_text_commentbox" id="ad_text_under_commentbox"&gt;&lt;/div&gt;
&lt;div id="site_nav_under"&gt;&lt;a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园"&gt;博客园首页&lt;/a&gt;&lt;a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区"&gt;博问&lt;/a&gt;&lt;a href="http://news.cnblogs.com/" target="_blank" title="IT新闻"&gt;新闻&lt;/a&gt;&lt;a href="http://home.cnblogs.com/ing/" target="_blank"&gt;闪存&lt;/a&gt;&lt;a href="http://job.cnblogs.com/" target="_blank"&gt;程序员招聘&lt;/a&gt;&lt;a href="http://kb.cnblogs.com/" target="_blank"&gt;知识库&lt;/a&gt;&lt;/div&gt;
&lt;div id="opt_under_post"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    var enableGoogleAd = canShowAdsense(); var googletag = googletag || {}; googletag.cmd = googletag.cmd || [];
    fixPostBodyFormat();
&lt;/script&gt;
&lt;div id="ad_under_post_holder"&gt;
&lt;script type='text/javascript'&gt;
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
    })();
&lt;/script&gt;
&lt;script type='text/javascript'&gt;
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function () {
                googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1346480159711-0').addService(googletag.pubads());
                googletag.pubads().enableSingleRequest();
                googletag.enableServices();
            });
        };
    } catch (e) { }
&lt;/script&gt;
&lt;div id="google_ad_c1" class="c_ad_block"&gt;
    &lt;div id='div-gpt-ad-1346480159711-0' style='width:300px; height:250px;'&gt;
    &lt;script type='text/javascript'&gt;
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1346480159711-0'); });            
            } else {
                $('#div-gpt-ad-1346480159711-0').hide();
            }
    } catch (e) { }
    &lt;/script&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="blog_news_kb"&gt;&lt;/div&gt;
&lt;div id="HistoryToday" class="c_ad_block"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
&lt;/script&gt;
&lt;/div&gt;

        &lt;/div&gt;

        &lt;script type="text/javascript"&gt;
            var m = window.__blog.contentRendered;
            if (m) { m(__$("content")); }
        &lt;/script&gt;

        &lt;div id="sidebar"&gt;
            
&lt;div id="about"&gt;
&lt;div&gt;
&lt;h2 id="about_title"&gt;About&lt;/h2&gt;
&lt;div id="about_body"&gt;
&lt;div id="blog-news"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;loadBlogNews();&lt;/script&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

            &lt;script type="text/javascript"&gt;
                var m = window.__blog.aboutRendered;
                if (m) { m(__$("about")); }
            &lt;/script&gt;
            
&lt;div id="mySearchWrapper"&gt;
    &lt;div id="mySearch"&gt;
        &lt;input type="image" src="/skins/Minyx2_Lite/images/btnsearch.gif" id="btnZzk" class="submit" onclick="zzk_go();return false;"&gt;
        &lt;label class="lb_search"&gt;&lt;input type="text" id="q" onkeydown="return zzk_go_enter(event);" class="keyword"&gt;&lt;/label&gt;
    &lt;/div&gt;
&lt;/div&gt;

            &lt;script type="text/javascript"&gt;
                var m = window.__blog.searchFormRendered;
                if (m) { m(__$("searchform")); }
            &lt;/script&gt;
            &lt;div id="sideMain"&gt;
            &lt;/div&gt;
            &lt;div id="sideRight"&gt;
            &lt;/div&gt;
            &lt;div id="sideLeft"&gt;
            &lt;/div&gt;
            
                &lt;div id="sideContainer"&gt;
                &lt;/div&gt;
                &lt;script type="text/javascript"&gt;
                    $.ajax({
                        url: '/' + currentBlogApp + '/mvc/blog/Minyx2_Lite_SideColumn.aspx',
                        data: '{}',
                        type: 'post',
                        dataType: 'text',
                        contentType: 'application/json; charset=utf-8',
                        success: function (data) {
                            if (data) {
                                $("#sideContainer").html(data);
                                loadBlogDefaultCalendar();
                                loadBlogSideBlocks();
                                var m = window.__blog.sideContainerRendered;
                                if (m) { m(__$("sideContainer")); }
                                window.__blog.sidebar.__layout();
                            }
                        }
                    });

                &lt;/script&gt;
            
        &lt;/div&gt;

        &lt;script type="text/javascript"&gt;
            var m = window.__blog.sidebarRendered;
            if (m) { m(__$("sidebar")); }
        &lt;/script&gt;

        &lt;div id="footer"&gt;
            
&lt;p id="logoFoot"&gt;
    &lt;a href="http://www.spiga.com.mx/" title="Agencia Interactiva Spiga"&gt;www.spiga.com.mx&lt;/a&gt;
&lt;/p&gt;
&lt;div class="footText"&gt;
&lt;p&gt;
Copyright &amp;copy;2014 KenshinCui
&lt;/p&gt;
&lt;p&gt;
&lt;a href="http://www.cnblogs.com"&gt;博客园&lt;/a&gt;
&lt;/p&gt;
&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script type="text/javascript"&gt;
        var m = window.__blog.wrapperRendered;
        if (m) { m(__$("wrapper")); }
    &lt;/script&gt;

&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    var m = window.__blog.containerRendered;
    if (m) { m(__$("container")); }
&lt;/script&gt;
&lt;!--PageEndHtml Block Begin--&gt;
&lt;!--&lt;script type="text/javascript" src=" http://v1.jiathis.com/code/jiathis_r.js" charset="utf-8"&gt;&lt;/script&gt;--&gt;
&lt;script type="text/javascript" src="http://files.cnblogs.com/kenshincui/scrolltopcontrol.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;script src="http://cdn.bootcss.com/bootstrap/3.2.0/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
$(document).ready(function () {
    var blogBodyId = 'cnblogs_post_body';
    if($('#'+blogBodyId).length===0){
        scrolltotop.init();
    }
    var iv=setInterval(function(){
        var digg=$("#div_digg");
        if(digg.length&gt;0){
            digg.css({ "position": "fixed", "right": "0px", "bottom":"0px", "z-index": "10", "background-color": "white", "margin":"10px", "padding": "10px", "border": "1px solid #cccccc" });
            clearInterval(iv);
        }
    },1000);

    $('.kc-table&gt;tbody&gt;tr[class!="subhead"]').hover(function(){
        $(this).addClass('active');
    },function(){
        $(this).removeClass('active');
    });

var $ol = $('.kc-catalog');
            if ($ol) {
                var height = $ol.height(),
                fontHeight = 80,
                $catalog,
                padding = (height - fontHeight) / 2;
                $catalog = $('&lt;li class="catalog"&gt;&lt;span&gt;目&lt;/span&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;span&gt;录&lt;span&gt;&lt;/li&gt;');
                $ol.append($catalog);
                $catalog.css('padding-top', padding).css('padding-bottom', padding);
            }
});
&lt;/script&gt;
&lt;script src="http://files.cnblogs.com/kenshincui/CNBlogsNavigation-0.5.2.min.js"&gt;&lt;/script&gt;
&lt;!--PageEndHtml Block End--&gt;
&lt;/body&gt;
&lt;/html&gt;
</Html>
	<HtmlMetas i:nil="true" />
	<HtmlTitle i:nil="true" />
	<IsDefault>false</IsDefault>
	<Layout i:nil="true" />
	<Name>-kenshincui-p-3959951.html</Name>
	<OutputCache i:nil="true" />
	<PageContents xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
	<Plugins xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<Published>false</Published>
	<RequireHttps>false</RequireHttps>
	<Routes>
		<PageRoute>
			<Defaults xmlns:d4p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
			<Identifier>/kenshincui/p/3959951.html</Identifier>
			<RoutePath i:nil="true" />
		</PageRoute>
	</Routes>
	<Scripts i:nil="true" />
	<Site>
		<AbsoluteName xmlns="Ovaldi.Core.Models">Cnblogs</AbsoluteName>
	</Site>
	<Styles i:nil="true" />
	<UUID>-kenshincui-p-3959951.html</UUID>
</Page>