<?xml version="1.0" encoding="utf-8"?>
<Page xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/Ovaldi.Core.Models">
	<AbsoluteName>-sharpxiajun-p-3950466.html</AbsoluteName>
	<CustomFields xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<EnableScript>true</EnableScript>
	<EnableTheming>true</EnableTheming>
	<Html>&lt;!DOCTYPE html&gt;
&lt;html lang="zh-cn"&gt;
&lt;head&gt;
&lt;meta charset="utf-8"&gt;
&lt;title&gt;关于如何提高Web服务端并发效率的异步编程技术 - 夏天的森林 - 博客园&lt;/title&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/bundles/blog-common.css"&gt;
&lt;link id="MainCss" type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/skins/LessIsMoreRight/bundle-LessIsMoreRight.css"&gt;
&lt;link type="text/css" rel="stylesheet" href="/preview~Cnblogs/Styles/blog/customcss/90635.css"&gt;
&lt;link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/sharpxiajun/rss"&gt;
&lt;link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/sharpxiajun/rsd.xml"&gt;
&lt;link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/sharpxiajun/wlwmanifest.xml"&gt;
&lt;script src="http://common.cnblogs.com/script/jquery.js" type="text/javascript"&gt;&lt;/script&gt;  
&lt;script type="text/javascript"&gt;var currentBlogApp = 'sharpxiajun', cb_enable_mathjax=false;&lt;/script&gt;
&lt;script src="/preview~Cnblogs/Scripts/bundles/blog-common.js" type="text/javascript"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;a name="top"&gt;&lt;/a&gt;
&lt;div id="page_begin_html"&gt;&lt;/div&gt;&lt;script&gt;load_page_begin_html();&lt;/script&gt;

&lt;div id="home"&gt;
&lt;div id="header"&gt;
	&lt;div id="blogTitle"&gt;
		
&lt;!--done--&gt;
&lt;div class="title"&gt;&lt;a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/sharpxiajun/"&gt;夏天的森林&lt;/a&gt;&lt;/div&gt;
&lt;div class="subtitle"&gt;Web前端及Web开发技术群，群号：262413025，聊一切和web开发相关的技术，什么web前端，web服务端，中间件，数据库，云计算，大数据，hadoop，喜欢这些的人都可以加入本群！&lt;/div&gt;



		
	&lt;/div&gt;&lt;!--end: blogTitle 博客的标题和副标题 --&gt;
	&lt;div id="navigator"&gt;
		
&lt;ul id="navList"&gt;
&lt;li id="nav_sitehome"&gt;&lt;a id="MyLinks1_HomeLink" class="menu" href="http://www.cnblogs.com/"&gt;博客园&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_myhome"&gt;&lt;a id="MyLinks1_MyHomeLink" class="menu" href="http://www.cnblogs.com/sharpxiajun/"&gt;首页&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_q"&gt;&lt;a class="menu" href="http://q.cnblogs.com/"&gt;博问&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_ing"&gt;&lt;a class="menu" href="http://home.cnblogs.com/ing/"&gt;闪存&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_newpost"&gt;&lt;a id="MyLinks1_NewPostLink" class="menu" rel="nofollow" href="http://i.cnblogs.com/EditPosts.aspx?opt=1"&gt;新随笔&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_contact"&gt;&lt;a id="MyLinks1_ContactLink" class="menu" rel="nofollow" href="http://space.cnblogs.com/msg/send/%e5%a4%8f%e5%a4%a9%e7%9a%84%e6%a3%ae%e6%9e%97"&gt;联系&lt;/a&gt;&lt;/li&gt;
&lt;li id="nav_rss"&gt;&lt;a id="MyLinks1_Syndication" class="menu" href="http://www.cnblogs.com/sharpxiajun/rss"&gt;订阅&lt;/a&gt;
&lt;!--&lt;a id="MyLinks1_XMLLink" class="aHeaderXML" href="http://www.cnblogs.com/sharpxiajun/rss"&gt;&lt;img src="http://www.cnblogs.com/images/xml.gif" alt="订阅" /&gt;&lt;/a&gt;--&gt;&lt;/li&gt;
&lt;li id="nav_admin"&gt;&lt;a id="MyLinks1_Admin" class="menu" rel="nofollow" href="http://i.cnblogs.com/"&gt;管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

		&lt;div class="blogStats"&gt;
			
			
&lt;!--done--&gt;
随笔-88&amp;nbsp;
文章-0&amp;nbsp;
评论-614&amp;nbsp;

			
		&lt;/div&gt;&lt;!--end: blogStats --&gt;
	&lt;/div&gt;&lt;!--end: navigator 博客导航栏 --&gt;
&lt;/div&gt;&lt;!--end: header 头部 --&gt;
&lt;div id="main"&gt;
	&lt;div id="mainContent"&gt;
	&lt;div class="forFlow"&gt;
		

&lt;!--done--&gt;
&lt;div id="topics"&gt;
	&lt;div class="post"&gt;
		&lt;h1 class="postTitle"&gt;
			&lt;a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/sharpxiajun/p/3950466.html"&gt;关于如何提高Web服务端并发效率的异步编程技术&lt;/a&gt;
		&lt;/h1&gt;
		&lt;div class="clear"&gt;&lt;/div&gt;
		&lt;div class="postBody"&gt;
			&lt;div id="cnblogs_post_body"&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　最近我研究技术的一个重点是java的多线程开发，在我早期学习java的时候，很多书上把java的多线程开发标榜为简单易用，这个简单易用是以C语言作为参照的，不过我也没有使用过C语言开发过多线程，我只知道我学习java多线程开发是很难的，直到现在写这篇文章的时候，虽然我对java多线程里的API比以前熟悉更多了，但是如果碰到了生产开发里如何将多线程设计更好，我心里的底气还是不足的，哎，缺乏很有意义的实践，我现在要等待让我实践这部分技术的机会了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　话外话，研究多线程是因为我在一本讲并发编程的书籍里看到书里作者把能做好并发编程的工程师叫做并发工程师，这和我研究web前端技术时候看到前端工程师的感受类似，因此我想找机会也把自己训练成为一名并发工程师。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　废话少说，回到本文的主题，作为一名web工程师都希望自己做的web应用能被越来越多的人使用，如果我们所做的web应用随着用户的增多而宕机了，那么越来越多的人就会变得越来越少了，为了让我们的web应用能有更多人使用，我们就得提升web应用服务端的并发能力。那么我们如何做到这点了，根据现有的并发技术我们会有如下选择：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　&lt;strong&gt;第一个做法&lt;/strong&gt;：为了每个客户端发送给服务端的请求都开启一个线程，等请求处理完毕后该线程就被销毁掉，这种做法很直观，但是在现代的web服务器里这种做法已经很少使用了，原因是新建一个线程，销毁一个线程的开销（开销是指占用计算机系统资源例如：cpu、内存等）是很大的，它时常会大于实际处理请求本身的开销，因此这种方式不能充分利用计算机资源，提升并发的效率是有效的，要是还碰到线程安全的问题，使用到线程的锁机制，数据同步技术，并发提升就会受到更大的限制；除此之外，来一个请求就开启一个线程，对线程数量没有任何控制，这就会很容易导致计算机资源被用尽，对于web服务端的稳定性产生很大的威胁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　&lt;strong&gt;第二个做法&lt;/strong&gt;：鉴于上面的问题，我们就产生了第二种提高服务端并发量的方法，首先我们不再是一个客户端请求过来就开启一个新线程，请求处理完毕就销毁线程，而是使用一种池技术即线程池技术，线程池技术就是事先创建一批线程，这批线程被放入到一个池子里，在没有请求到达服务端时候，这些线程都是处于待命状态，当请求到达时候，程序会从线程池里取出一个线程，这个线程处理到达的请求，请求处理完毕，该线程不会被销毁，而是被线程池回收，这种方式使用线程我们降低了随意创建线程和销毁线程所导致系统开销，同时也控制了服务端线程的数量，一般一个线程对应一个请求，也就控制了并发请求的个数，该方案比第一种方案提升了系统的稳定性（控制并发数量，防止并发过多导致服务程序宕机）同时也提升了并发的数量（原因是减少了创建线程和销毁线程的开销，更充分的利用了计算机的系统资源）。但是做法二也是有很大的问题的，具体如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　做法二和做法一相比，做法二要好多了，但是这只是和做法一比，如果按照我们设计的目标，做法二并非完美，原因如下：首先做法二会让很多技术不扎实人认为线程池开启多少线程就决定了系统并发的数量，因此出于让系统能处理更多请求以及充分利用计算机资源的考虑，有些人会一开始就把线程池里新建线程的个数设置为最大，一个web应用的并发量在一定时间里都是一个曲线形式，峰值在一定时间范围内都是少数情况，因此一开始就开启最大线程数，自然在大多数时间内都是在浪费系统资源，如果这些被浪费被闲置的计算资源能用来处理请求，或许这些请求处理的效率会更高。此外，一个服务器到底预先开启多少个线程，这个标准很难把控，还有就是不管你用线程池技术还是新建线程的方式，处理请求的数量和线程数量数量是一一对应的关系，如果有一个时间点过来的请求数量正好超出了线程池里线程数量，例如就多了一个，那么这个请求因为找不到对应线程很有可能会被程序所遗弃掉，其实这多的一个请求并没有超出计算机所能承受的负载，而是因为我们程序设计不合理才被遗弃的，这肯定是开发人员所不愿意发生的事情，针对这些问题在java的JDK里提供的线程池做了很好的解决（线程池技术是博大精深的，如果我们没有研究透池技术，还是不要自己去写个而是用现成的），jdk里的线程池对线程池大小的设定使用两个参数，一个是核心线程个数，一个是最大线程个数，核心线程在系统启动时候就会被创建，如果用户请求没有超过核心线程处理能力，那么线程池不会再创建新线程，如果核心线程个数已经处理不过来了，线程池就会开启新线程，新线程第一次创建后，使用完毕后也不是立即对其销毁，也是被会收到线程池里，当线程池里的线程总数超过了最大线程个数，线程池将不会再创建新线程，这种做法让线程数量根据实际请求的情况进行调整，这样既达到了充分利用计算机资源的目的，同时也避免了系统资源的浪费，jdk的线程池还有个超时时间，当超出核心线程的线程在一定时间内一直未被使用，那么这些线程将会被销毁，资源就会被释放，这样就让线程池的线程的数量总是处在一个合理的范围里；如果请求实在太多了，线程池里的线程暂时处理不过来了，jdk的线程池还提供一个队列机制，让这些请求排队等待，当某个线程处理完毕，该线程又会从这个队列里取出一个请求进行处理，这样就避免请求的丢失，jdk的线程池对队列的管理有很多策略，有兴趣的童鞋可以问问度娘，这里我还要说的是jdk线程池的安全策略做的很好，如果队列的容量超出了计算机的处理能力，队列会抛弃无法处理的请求，这个也叫做线程池的拒绝策略。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　看我这么详细的描述做法二，是不是做法二就是一个完美的方案了？答案当然是否定了，做法二并非最高效的方案，做法二也没有充分利用好计算机的系统资源，我这里还有&lt;strong&gt;做法三&lt;/strong&gt;了，其具体做法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　首先我要提出一个问题，并发处理一个任务和单线程的处理同样一个任务，那种方式的效率更高？也许有很多人会认为当然是并发处理任务效率更高了，两个人做一件事情总比一个人要厉害吧，这个问题的答案是要看场景的，在单核时代，单线程处理一个任务的效率往往会比并发方式效率更高，为什么呢？因为多线程在单核即单个cpu上运算，cpu并不是也可以并发处理的，cpu每次都只能处理一个计算任务，因此并发任务对于cpu而言就有线程的上下文切换操作，而这种线程上下文的开销是比较大的，因此单核上处理并发请求不一定会比单线程更有效率，但是如果到了多核的计算机，并发任务平均分配给每一个cpu，那么并发处理的效率就会比单线程处理要高很多，因为此时可以避免线程上下文的切换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　对于一个网络请求的处理，是由两个不同类型的操作共同完成，这两个操作是CPU的计算操作和IO操作，如果我们以处理效率角度来评判这两个操作，CPU操作效率是光速的，而IO操作就不尽然了，计算机里的IO操作就是对存储数据介质的操作，计算机里有如下几个介质可以存储数据，它们分别是：CPU的一级缓存、二级缓存、内存、硬盘和网络，一级缓存存储和读取数据的能力接近光速，它比二级缓存快个5倍到6倍，但是不管是一级缓存还是二级缓存，它们存储数据量太少了，做不了什么大事情，下面就是内存了，以一级缓存的效率做参照，一级缓存比内存速度快100多倍，到了硬盘存储和读取数据效率就更慢了，一级缓存比硬盘要快1000多万倍，到了网络就慢的更不像话了，一级缓存比网络要快一亿多倍，可见一个请求处理的效率瓶颈都是由IO引起的，而CPU虽然处理很快但是CPU对任务的计算都是一个接着一个处理，假如一个请求首先要等待网络数据的处理在进行CPU运算，那么必然就拖慢了CPU的处理的整体效率，这一慢就是上亿倍了，但是现实中一个网络请求处理就是由这两个操作组合而成的。对于IO操作在java里有两种方式，一种方式叫做阻塞的IO，一种方式叫做非阻塞的IO，阻塞的IO就是在做IO操作时候，CPU要等待IO操作，这就造成了CPU计算资源的浪费，浪费的程度上文里已经写到了，是很可怕的，因此我们就想当一个请求一个线程做IO操作时候，CPU不用等待它而是接着处理其他的线程和请求，这种做法效率必然很高，这时候非阻塞IO就登场了，非阻塞IO可以在线程进行IO操作时候让CPU去处理别的线程，那么非阻塞IO怎么做到这一点的呢？非阻塞IO操作在请求和cpu计算之间添加了一个中间层，请求先发到这个中间层，中间层获取了请求后就直接通知请求发送者，请求接收到了，注意这个时候中间层啥都没干，只是接收了请求，真正的计算任务还没开始哦，这个时候中间层如果要CPU处理那么就让cpu处理，如果计算过程到了要进行IO操作，中间层就告诉cpu不用等我了，中间层就让请求做IO操作，CPU这时候可以处理别的请求，等IO操作做完了，中间层再把任务交给CPU去处理，处理完成后，中间层将处理结果再发送给客户端，这种方式就可以充分利用CPU的计算机资源，有了非阻塞IO其实使用单线程也可以开发多线程任务，甚至这个单线程的处理效率可能比多线程更高，因为它没有线程创建销毁的开销，也没有线程上下文切换的开销。其实实现一个非阻塞的请求是个大课题，里面使用到了很多先进和复杂的技术例如：回调函数和轮询等，对于非阻塞的开发我目前掌握的还不够好，等我有天完全掌握了它我一定会再写一篇文章，不过这里要提到的是像java里netty技术，nginx，php的并发处理都用到这种机制的原理，特别是现在很火的nodejs它产生的原因就是依靠这种非阻塞的技术来编写更高效的web服务器，可以说nodejs把这种技术用到了极致，不过这里要纠正下，非阻塞是针对IO操作的技术，对于nodejs，netty的实现机制有更好的术语描述就是事件驱动（其实就是使用回调函数，观察者模式实现的）以及异步的IO技术（就是非阻塞的IO技术）。现在我们回到做法三的描述，做法三的核心思想就是让每个线程资源利用率更加有效，做法三是建立在做法二的基础上，使用事件驱动的开发思想，采用非阻塞的IO编程模式，当客户端多个请求发到服务端，服务端可以只用一个线程对这些请求进行处理，利用IO操作的性能瓶颈，充分利用CPU的计算能力，这样就达到一个线程处理多个请求的效率并不比多线程差，甚至还高，同时单线程处理能力的增强也会导致整个web服务并发性能的提升。大家可以想想，按这种方式在一个多核服务器下，假如这个服务器有8个内核，每个内核开启一个线程，这8个线程也许就能承载数千并发量，同时也充分利用每个CPU计算能力，如果我们开启线程越多（当然新增的线程数最好是8的倍数，这样对多核利用率更好）那么并发的效率也就更高，提升是按几何倍数进行的，大家想想nginx，它就采用此模式，所以它刚推出来的时候其并发处理能力是apache服务器的数倍，现在nginx已经和apache一样普及了，事件驱动的异步机制功不可没。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span style="font-family: 'Microsoft YaHei'; font-size: 18px;"&gt;　　好了，文章写毕，今天写这篇文章算是对我最近研究多线程的一点总结，也是我最近转向研究nodejs的开始，nodejs有完美的异步编程模型，但是最近我确一直怀疑它的并发能力，因为我一直没找到nodejs里像java里那么复杂的异步编程技术，现在我发现，nodejs用了一种更加巧妙的方式解决异步开发的问题，而且这种方式是高效，就这一点nodejs太有魅力了，所以很值得研究和学习。&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;&lt;div id="MySignature"&gt;&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="blog_post_info_block"&gt;
&lt;div id="BlogPostCategory"&gt;&lt;/div&gt;
&lt;div id="EntryTag"&gt;&lt;/div&gt;
&lt;div id="blog_post_info"&gt;
&lt;/div&gt;
&lt;div class="clear"&gt;&lt;/div&gt;
&lt;div id="post_next_prev"&gt;&lt;/div&gt;
&lt;/div&gt;


		&lt;/div&gt;
		&lt;div class="postDesc"&gt;posted @ &lt;span id="post-date"&gt;2014-09-01 22:51&lt;/span&gt; &lt;a href='http://www.cnblogs.com/sharpxiajun/'&gt;夏天的森林&lt;/a&gt; 阅读(&lt;span id="post_view_count"&gt;...&lt;/span&gt;) 评论(&lt;span id="post_comment_count"&gt;...&lt;/span&gt;)  &lt;a href="http://i.cnblogs.com/EditPosts.aspx?postid=3950466" rel="nofollow"&gt;编辑&lt;/a&gt; &lt;a href="#" onclick="AddToWz(3950466);return false;"&gt;收藏&lt;/a&gt;&lt;/div&gt;
	&lt;/div&gt;
	&lt;script type="text/javascript"&gt;var allowComments=true,isLogined=false,cb_blogId=90635,cb_entryId=3950466,cb_blogApp=currentBlogApp,cb_blogUserGuid='5f788e31-e290-e011-a53f-842b2b196315',cb_entryCreatedDate='2014/9/1 22:51:00';loadViewCount(cb_entryId);&lt;/script&gt;
	
&lt;/div&gt;&lt;!--end: topics 文章、评论容器--&gt;
&lt;a name="!comments"&gt;&lt;/a&gt;&lt;div id="blog-comments-placeholder"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;var commentManager = new blogCommentManager();commentManager.renderComments(0);&lt;/script&gt;
&lt;div id="comment_form" class="commentform"&gt;
&lt;a name="commentform"&gt;&lt;/a&gt;
&lt;div id="divCommentShow"&gt;&lt;/div&gt;
&lt;div id="comment_nav"&gt;&lt;span id="span_refresh_tips"&gt;&lt;/span&gt;&lt;a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();"&gt;刷新评论&lt;/a&gt;&lt;a href="#" onclick="return RefreshPage();"&gt;刷新页面&lt;/a&gt;&lt;a href="#top"&gt;返回顶部&lt;/a&gt;&lt;/div&gt;
&lt;div id="comment_form_container"&gt;&lt;/div&gt;
&lt;div class="ad_text_commentbox" id="ad_text_under_commentbox"&gt;&lt;/div&gt;
&lt;div id="site_nav_under"&gt;&lt;a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园"&gt;博客园首页&lt;/a&gt;&lt;a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区"&gt;博问&lt;/a&gt;&lt;a href="http://news.cnblogs.com/" target="_blank" title="IT新闻"&gt;新闻&lt;/a&gt;&lt;a href="http://home.cnblogs.com/ing/" target="_blank"&gt;闪存&lt;/a&gt;&lt;a href="http://job.cnblogs.com/" target="_blank"&gt;程序员招聘&lt;/a&gt;&lt;a href="http://kb.cnblogs.com/" target="_blank"&gt;知识库&lt;/a&gt;&lt;/div&gt;
&lt;div id="opt_under_post"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
    var enableGoogleAd = canShowAdsense(); var googletag = googletag || {}; googletag.cmd = googletag.cmd || [];
    fixPostBodyFormat();
&lt;/script&gt;
&lt;div id="ad_under_post_holder"&gt;
&lt;script type='text/javascript'&gt;
    var googletag = googletag || {};
    googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') + '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
    })();
&lt;/script&gt;
&lt;script type='text/javascript'&gt;
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function () {
                googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1346480159711-0').addService(googletag.pubads());
                googletag.pubads().enableSingleRequest();
                googletag.enableServices();
            });
        };
    } catch (e) { }
&lt;/script&gt;
&lt;div id="google_ad_c1" class="c_ad_block"&gt;
    &lt;div id='div-gpt-ad-1346480159711-0' style='width:300px; height:250px;'&gt;
    &lt;script type='text/javascript'&gt;
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1346480159711-0'); });            
            } else {
                $('#div-gpt-ad-1346480159711-0').hide();
            }
    } catch (e) { }
    &lt;/script&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="blog_news_kb"&gt;&lt;/div&gt;
&lt;div id="HistoryToday" class="c_ad_block"&gt;&lt;/div&gt;
&lt;script type="text/javascript"&gt;
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
&lt;/script&gt;
&lt;/div&gt;

	&lt;/div&gt;&lt;!--end: forFlow --&gt;
	&lt;/div&gt;&lt;!--end: mainContent 主体内容容器--&gt;

	&lt;div id="sideBar"&gt;
		&lt;div id="sideBarMain"&gt;
			
&lt;!--done--&gt;
&lt;div class="newsItem"&gt;
&lt;h3 class="catListTitle"&gt;公告&lt;/h3&gt;
	&lt;div id="blog-news"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogNews();&lt;/script&gt;
&lt;/div&gt;

			&lt;div id="calendar"&gt;&lt;div id="blog-calendar" style="display:none"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogDefaultCalendar();&lt;/script&gt;&lt;/div&gt;
			
			&lt;div id="leftcontentcontainer"&gt;
				&lt;div id="blog-sidecolumn"&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;loadBlogSideColumn();&lt;/script&gt;
			&lt;/div&gt;
			
		&lt;/div&gt;&lt;!--end: sideBarMain --&gt;
	&lt;/div&gt;&lt;!--end: sideBar 侧边栏容器 --&gt;
	&lt;div class="clear"&gt;&lt;/div&gt;
	&lt;/div&gt;&lt;!--end: main --&gt;
	&lt;div class="clear"&gt;&lt;/div&gt;
	&lt;div id="footer"&gt;
		
&lt;!--done--&gt;
Copyright &amp;copy;2014 夏天的森林
	&lt;/div&gt;&lt;!--end: footer --&gt;
&lt;/div&gt;&lt;!--end: home 自定义的最大容器 --&gt;
&lt;/body&gt;
&lt;/html&gt;
</Html>
	<HtmlMetas i:nil="true" />
	<HtmlTitle i:nil="true" />
	<IsDefault>false</IsDefault>
	<Layout i:nil="true" />
	<Name>-sharpxiajun-p-3950466.html</Name>
	<OutputCache i:nil="true" />
	<PageContents xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
	<Plugins xmlns:d2p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" />
	<Published>false</Published>
	<RequireHttps>false</RequireHttps>
	<Routes>
		<PageRoute>
			<Defaults xmlns:d4p1="http://schemas.microsoft.com/2003/10/Serialization/Arrays" i:nil="true" />
			<Identifier>/sharpxiajun/p/3950466.html</Identifier>
			<RoutePath i:nil="true" />
		</PageRoute>
	</Routes>
	<Scripts i:nil="true" />
	<Site>
		<AbsoluteName xmlns="Ovaldi.Core.Models">Cnblogs</AbsoluteName>
	</Site>
	<Styles i:nil="true" />
	<UUID>-sharpxiajun-p-3950466.html</UUID>
</Page>